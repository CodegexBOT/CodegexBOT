[{"sha":"b8c791063b8708a32602952ad1f8d31c29288640","filename":"src/main/java/META-INF/MANIFEST.MF","status":"added","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/META-INF/MANIFEST.MF","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/META-INF/MANIFEST.MF","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/META-INF/MANIFEST.MF?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,3 @@\n+Manifest-Version: 1.1.35\r\n+Class-Path: \r\n+\r"},{"sha":"d1a76db889d96ba560f7dff6b9a01c6a384f4b51","filename":"src/main/java/com/alibaba/fastjson/JSON.java","status":"added","additions":1425,"deletions":0,"changes":1425,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSON.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSON.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSON.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,1425 @@\n+/*\n+ * Copyright 1999-2017 Alibaba Group.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.fastjson;\n+\n+import java.io.*;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Type;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.zip.GZIPInputStream;\n+\n+import com.alibaba.fastjson.annotation.JSONType;\n+import com.alibaba.fastjson.parser.*;\n+import com.alibaba.fastjson.parser.deserializer.ExtraProcessor;\n+import com.alibaba.fastjson.parser.deserializer.ExtraTypeProvider;\n+import com.alibaba.fastjson.parser.deserializer.FieldTypeResolver;\n+import com.alibaba.fastjson.parser.deserializer.ParseProcess;\n+import com.alibaba.fastjson.serializer.*;\n+import com.alibaba.fastjson.util.IOUtils;\n+import com.alibaba.fastjson.util.TypeUtils;\n+\n+/**\n+ * This is the main class for using Fastjson. You usually call these two methods {@link #toJSONString(Object)} and {@link #parseObject(String, Class)}.\n+ * \n+ * <p>Here is an example of how fastjson is used for a simple Class:\n+ *\n+ * <pre>\n+ * Model model = new Model();\n+ * String json = JSON.toJSONString(model); // serializes model to Json\n+ * Model model2 = JSON.parseObject(json, Model.class); // deserializes json into model2\n+ * </pre>\n+ * \n+* <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}\n+ * (i.e. contains at least one type parameter and may be an array) then you must use the\n+ * {@link #toJSONString(Object)} or {@link #parseObject(String, Type, Feature[])} method.  Here is an\n+ * example for serializing and deserialing a {@code ParameterizedType}:\n+ * \n+ * <pre>\n+ * String json = \"[{},...]\";\n+ * Type listType = new TypeReference&lt;List&lt;Model&gt;&gt;() {}.getType();\n+ * List&lt;Model&gt; modelList = JSON.parseObject(json, listType);\n+ * </pre>\n+ * \n+ * @see com.alibaba.fastjson.TypeReference\n+ * \n+ * @author wenshao[szujobs@hotmail.com]\n+ */\n+public abstract class JSON implements JSONStreamAware, JSONAware {\n+    public static TimeZone         defaultTimeZone      = TimeZone.getDefault();\n+    public static Locale           defaultLocale        = Locale.getDefault();\n+    public static String           DEFAULT_TYPE_KEY     = \"@type\";\n+    static final SerializeFilter[] emptyFilters         = new SerializeFilter[0];\n+    public static String           DEFFAULT_DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n+    public static int              DEFAULT_PARSER_FEATURE;\n+    public static int              DEFAULT_GENERATE_FEATURE;\n+\n+    private static final ConcurrentHashMap<Type, Type> mixInsMapper = new ConcurrentHashMap<Type, Type>(16);\n+    \n+    static {\n+        int features = 0;\n+        features |= Feature.AutoCloseSource.getMask();\n+        features |= Feature.InternFieldNames.getMask();\n+        features |= Feature.UseBigDecimal.getMask();\n+        features |= Feature.AllowUnQuotedFieldNames.getMask();\n+        features |= Feature.AllowSingleQuotes.getMask();\n+        features |= Feature.AllowArbitraryCommas.getMask();\n+        features |= Feature.SortFeidFastMatch.getMask();\n+        features |= Feature.IgnoreNotMatch.getMask();\n+        DEFAULT_PARSER_FEATURE = features;\n+    }\n+\n+    static {\n+        int features = 0;\n+        features |= SerializerFeature.QuoteFieldNames.getMask();\n+        features |= SerializerFeature.SkipTransientField.getMask();\n+        features |= SerializerFeature.WriteEnumUsingName.getMask();\n+        features |= SerializerFeature.SortField.getMask();\n+\n+        DEFAULT_GENERATE_FEATURE = features;\n+\n+        config(IOUtils.DEFAULT_PROPERTIES);\n+    }\n+\n+    private static void config(Properties properties) {\n+        {\n+            String featuresProperty = properties.getProperty(\"fastjson.serializerFeatures.MapSortField\");\n+            int mask = SerializerFeature.MapSortField.getMask();\n+            if (\"true\".equals(featuresProperty)) {\n+                DEFAULT_GENERATE_FEATURE |= mask;\n+            } else if (\"false\".equals(featuresProperty)) {\n+                DEFAULT_GENERATE_FEATURE &= ~mask;\n+            }\n+        }\n+\n+        {\n+            if (\"true\".equals(properties.getProperty(\"parser.features.NonStringKeyAsString\"))) {\n+                DEFAULT_PARSER_FEATURE |= Feature.NonStringKeyAsString.getMask();\n+            }\n+        }\n+\n+        {\n+            if (\"true\".equals(properties.getProperty(\"parser.features.ErrorOnEnumNotMatch\"))\n+                    || \"true\".equals(properties.getProperty(\"fastjson.parser.features.ErrorOnEnumNotMatch\")))\n+            {\n+                DEFAULT_PARSER_FEATURE |= Feature.ErrorOnEnumNotMatch.getMask();\n+            }\n+        }\n+\n+        {\n+            if (\"false\".equals(properties.getProperty(\"fastjson.asmEnable\"))) {\n+                ParserConfig.global.setAsmEnable(false);\n+                SerializeConfig.globalInstance.setAsmEnable(false);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * config default type key\n+     * @since 1.2.14\n+     */\n+    public static void setDefaultTypeKey(String typeKey) {\n+        DEFAULT_TYPE_KEY = typeKey;\n+        ParserConfig.global.symbolTable.addSymbol(typeKey, \n+                                                  0, \n+                                                  typeKey.length(), \n+                                                  typeKey.hashCode(), true);\n+    }\n+    \n+    public static Object parse(String text) {\n+        return parse(text, DEFAULT_PARSER_FEATURE);\n+    }\n+\n+    /**\n+     *\n+     * @since 1.2.38\n+     */\n+    public static Object parse(String text, ParserConfig config) {\n+        return parse(text, config, DEFAULT_PARSER_FEATURE);\n+    }\n+\n+    /**\n+     *\n+     * @since 1.2.68\n+     */\n+    public static Object parse(String text, ParserConfig config, Feature... features) {\n+        int featureValues = DEFAULT_PARSER_FEATURE;\n+        for (Feature feature : features) {\n+            featureValues = Feature.config(featureValues, feature, true);\n+        }\n+\n+        return parse(text, config, featureValues);\n+    }\n+\n+    /**\n+     *\n+     * @since 1.2.38\n+     */\n+    public static Object parse(String text, ParserConfig config, int features) {\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        DefaultJSONParser parser = new DefaultJSONParser(text, config, features);\n+        Object value = parser.parse();\n+\n+        parser.handleResovleTask(value);\n+\n+        parser.close();\n+\n+        return value;\n+    }\n+\n+    public static Object parse(String text, int features) {\n+        return parse(text, ParserConfig.getGlobalInstance(), features);\n+    }\n+\n+    public static Object parse(byte[] input, Feature... features) {\n+        char[] chars = allocateChars(input.length);\n+        int len = IOUtils.decodeUTF8(input, 0, input.length, chars);\n+        if (len < 0) {\n+            return null;\n+        }\n+        return parse(new String(chars, 0, len), features);\n+    }\n+\n+    public static Object parse(byte[] input, int off, int len, CharsetDecoder charsetDecoder, Feature... features) {\n+        if (input == null || input.length == 0) {\n+            return null;\n+        }\n+\n+        int featureValues = DEFAULT_PARSER_FEATURE;\n+        for (Feature feature : features) {\n+            featureValues = Feature.config(featureValues, feature, true);\n+        }\n+\n+        return parse(input, off, len, charsetDecoder, featureValues);\n+    }\n+\n+    public static Object parse(byte[] input, int off, int len, CharsetDecoder charsetDecoder, int features) {\n+        charsetDecoder.reset();\n+\n+        int scaleLength = (int) (len * (double) charsetDecoder.maxCharsPerByte());\n+        char[] chars = allocateChars(scaleLength);\n+\n+        ByteBuffer byteBuf = ByteBuffer.wrap(input, off, len);\n+        CharBuffer charBuf = CharBuffer.wrap(chars);\n+        IOUtils.decode(charsetDecoder, byteBuf, charBuf);\n+\n+        int position = charBuf.position();\n+\n+        DefaultJSONParser parser = new DefaultJSONParser(chars, position, ParserConfig.getGlobalInstance(), features);\n+        Object value = parser.parse();\n+\n+        parser.handleResovleTask(value);\n+\n+        parser.close();\n+\n+        return value;\n+    }\n+\n+    public static Object parse(String text, Feature... features) {\n+        int featureValues = DEFAULT_PARSER_FEATURE;\n+        for (Feature feature : features) {\n+            featureValues = Feature.config(featureValues, feature, true);\n+        }\n+\n+        return parse(text, featureValues);\n+    }\n+\n+    public static JSONObject parseObject(String text, Feature... features) {\n+        return (JSONObject) parse(text, features);\n+    }\n+\n+    public static JSONObject parseObject(String text) {\n+        Object obj = parse(text);\n+        if (obj instanceof JSONObject) {\n+            return (JSONObject) obj;\n+        }\n+\n+        try {\n+            return (JSONObject) JSON.toJSON(obj);\n+        } catch (RuntimeException e) {\n+            throw new JSONException(\"can not cast to JSONObject.\", e);\n+        }\n+    }\n+\n+    /**\n+     * <pre>\n+     * String jsonStr = \"[{\\\"id\\\":1001,\\\"name\\\":\\\"Jobs\\\"}]\";\n+     * List&lt;Model&gt; models = JSON.parseObject(jsonStr, new TypeReference&lt;List&lt;Model&gt;&gt;() {});\n+     * </pre>\n+     * @param text json string\n+     * @param type type refernce\n+     * @param features\n+     * @return\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(String text, TypeReference<T> type, Feature... features) {\n+        return (T) parseObject(text, type.type, ParserConfig.global, DEFAULT_PARSER_FEATURE, features);\n+    }\n+\n+    /**\n+     * \n+     * This method deserializes the specified Json into an object of the specified class. It is not\n+     * suitable to use if the specified class is a generic type since it will not have the generic\n+     * type information because of the Type Erasure feature of Java. Therefore, this method should not\n+     * be used if the desired type is a generic type. Note that this method works fine if the any of\n+     * the fields of the specified object are generics, just the object itself should not be a\n+     * generic type. For the cases when the object is of generic type, invoke\n+     * {@link #parseObject(String, Type, Feature[])}. If you have the Json in a {@link InputStream} instead of\n+     * a String, use {@link #parseObject(InputStream, Type, Feature[])} instead.\n+     *\n+     * @param json the string from which the object is to be deserialized\n+     * @param clazz the class of T\n+     * @param features parser features\n+     * @return an object of type T from the string\n+     * classOfT\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(String json, Class<T> clazz, Feature... features) {\n+        return (T) parseObject(json, (Type) clazz, ParserConfig.global, null, DEFAULT_PARSER_FEATURE, features);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(String text, Class<T> clazz, ParseProcess processor, Feature... features) {\n+        return (T) parseObject(text, (Type) clazz, ParserConfig.global, processor, DEFAULT_PARSER_FEATURE,\n+                               features);\n+    }\n+\n+    /**\n+     * This method deserializes the specified Json into an object of the specified type. This method\n+     * is useful if the specified object is a generic type. For non-generic objects, use\n+     * {@link #parseObject(String, Class, Feature[])} instead. If you have the Json in a {@link InputStream} instead of\n+     * a String, use {@link #parseObject(InputStream, Type, Feature[])} instead.\n+     *\n+     * @param <T> the type of the desired object\n+     * @param json the string from which the object is to be deserialized\n+     * @param type The specific genericized type of src. You can obtain this type by using the\n+     * {@link com.alibaba.fastjson.TypeReference} class. For example, to get the type for\n+     * {@code Collection<Foo>}, you should use:\n+     * <pre>\n+     * Type type = new TypeReference&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n+     * </pre>\n+     * @return an object of type T from the string\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(String json, Type type, Feature... features) {\n+        return (T) parseObject(json, type, ParserConfig.global, DEFAULT_PARSER_FEATURE, features);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(String input, Type clazz, ParseProcess processor, Feature... features) {\n+        return (T) parseObject(input, clazz, ParserConfig.global, processor, DEFAULT_PARSER_FEATURE, features);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(String input, Type clazz, int featureValues, Feature... features) {\n+        if (input == null) {\n+            return null;\n+        }\n+\n+        for (Feature feature : features) {\n+            featureValues = Feature.config(featureValues, feature, true);\n+        }\n+\n+        DefaultJSONParser parser = new DefaultJSONParser(input, ParserConfig.getGlobalInstance(), featureValues);\n+        T value = (T) parser.parseObject(clazz);\n+\n+        parser.handleResovleTask(value);\n+\n+        parser.close();\n+\n+        return (T) value;\n+    }\n+    \n+    /**\n+     * @since 1.2.11\n+     */\n+    public static <T> T parseObject(String input, Type clazz, ParserConfig config, Feature... features) {\n+        return parseObject(input, clazz, config, null, DEFAULT_PARSER_FEATURE, features);\n+    }\n+\n+    public static <T> T parseObject(String input, Type clazz, ParserConfig config, int featureValues,\n+                                          Feature... features) {\n+        return parseObject(input, clazz, config, null, featureValues, features);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(String input, Type clazz, ParserConfig config, ParseProcess processor,\n+                                          int featureValues, Feature... features) {\n+        if (input == null || input.length() == 0) {\n+            return null;\n+        }\n+\n+        if (features != null) {\n+            for (Feature feature : features) {\n+                featureValues |= feature.mask;\n+            }\n+        }\n+\n+        DefaultJSONParser parser = new DefaultJSONParser(input, config, featureValues);\n+\n+        if (processor != null) {\n+            if (processor instanceof ExtraTypeProvider) {\n+                parser.getExtraTypeProviders().add((ExtraTypeProvider) processor);\n+            }\n+\n+            if (processor instanceof ExtraProcessor) {\n+                parser.getExtraProcessors().add((ExtraProcessor) processor);\n+            }\n+\n+            if (processor instanceof FieldTypeResolver) {\n+                parser.setFieldTypeResolver((FieldTypeResolver) processor);\n+            }\n+        }\n+\n+        T value = (T) parser.parseObject(clazz, null);\n+\n+        parser.handleResovleTask(value);\n+\n+        parser.close();\n+\n+        return (T) value;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(byte[] bytes, Type clazz, Feature... features) {\n+        return (T) parseObject(bytes, 0, bytes.length, IOUtils.UTF8, clazz, features);\n+    }\n+    \n+    /**\n+     * @since 1.2.11\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(byte[] bytes, int offset, int len, Charset charset, Type clazz, Feature... features) {\n+        return (T) parseObject(bytes, offset, len, charset, clazz, ParserConfig.global, null, DEFAULT_PARSER_FEATURE, features);\n+    }\n+\n+    /**\n+     * @since 1.2.55\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(byte[] bytes,\n+                                    Charset charset,\n+                                    Type clazz,\n+                                    ParserConfig config,\n+                                    ParseProcess processor,\n+                                    int featureValues,\n+                                    Feature... features) {\n+        return (T) parseObject(bytes, 0, bytes.length, charset, clazz, config, processor, featureValues, features);\n+    }\n+\n+    /**\n+     * @since 1.2.55\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(byte[] bytes, int offset, int len,\n+                                    Charset charset,\n+                                    Type clazz,\n+                                    ParserConfig config,\n+                                    ParseProcess processor,\n+                                    int featureValues,\n+                                    Feature... features) {\n+        if (charset == null) {\n+            charset = IOUtils.UTF8;\n+        }\n+\n+        String strVal = null;\n+        if (charset == IOUtils.UTF8) {\n+            char[] chars = allocateChars(bytes.length);\n+            int chars_len = IOUtils.decodeUTF8(bytes, offset, len, chars);\n+\n+            if (chars_len < 0) {\n+                InputStreamReader gzipReader = null;\n+                try {\n+                    gzipReader = new InputStreamReader(\n+                            new GZIPInputStream(\n+                                    new ByteArrayInputStream(bytes, offset, len)), \"UTF-8\");\n+                    strVal = IOUtils.readAll(gzipReader);\n+                } catch (Exception ex) {\n+                    return null;\n+                } finally {\n+                    IOUtils.close(gzipReader);\n+                }\n+            }\n+            if (strVal == null && chars_len < 0) {\n+                return null;\n+            }\n+\n+            if (strVal == null) {\n+                strVal = new String(chars, 0, chars_len);\n+            }\n+        } else {\n+            if (len < 0) {\n+                return null;\n+            }\n+            strVal = new String(bytes, offset, len, charset);\n+        }\n+        return (T) parseObject(strVal, clazz, config, processor, featureValues, features);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(byte[] input, //\n+                                    int off, //\n+                                    int len, //\n+                                    CharsetDecoder charsetDecoder, //\n+                                    Type clazz, //\n+                                    Feature... features) {\n+        charsetDecoder.reset();\n+\n+        int scaleLength = (int) (len * (double) charsetDecoder.maxCharsPerByte());\n+        char[] chars = allocateChars(scaleLength);\n+\n+        ByteBuffer byteBuf = ByteBuffer.wrap(input, off, len);\n+        CharBuffer charByte = CharBuffer.wrap(chars);\n+        IOUtils.decode(charsetDecoder, byteBuf, charByte);\n+\n+        int position = charByte.position();\n+\n+        return (T) parseObject(chars, position, clazz, features);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(char[] input, int length, Type clazz, Feature... features) {\n+        if (input == null || input.length == 0) {\n+            return null;\n+        }\n+\n+        int featureValues = DEFAULT_PARSER_FEATURE;\n+        for (Feature feature : features) {\n+            featureValues = Feature.config(featureValues, feature, true);\n+        }\n+\n+        DefaultJSONParser parser = new DefaultJSONParser(input, length, ParserConfig.getGlobalInstance(), featureValues);\n+        T value = (T) parser.parseObject(clazz);\n+\n+        parser.handleResovleTask(value);\n+\n+        parser.close();\n+\n+        return (T) value;\n+    }\n+    \n+    /**\n+     * @since 1.2.11\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(InputStream is, //\n+                                    Type type, //\n+                                    Feature... features) throws IOException {\n+        return (T) parseObject(is, IOUtils.UTF8, type, features);\n+    }\n+    \n+    /**\n+     * @since 1.2.11\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(InputStream is, //\n+                                    Charset charset, //\n+                                    Type type, //\n+                                    Feature... features) throws IOException {\n+        return (T) parseObject(is, charset, type, ParserConfig.global, features);\n+    }\n+\n+    /**\n+     * @since 1.2.55\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(InputStream is, //\n+                                    Charset charset, //\n+                                    Type type, //\n+                                    ParserConfig config, //\n+                                    Feature... features) throws IOException {\n+        return (T) parseObject(is, charset, type, config, null, DEFAULT_PARSER_FEATURE, features);\n+    }\n+\n+    /**\n+     * @since 1.2.55\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T parseObject(InputStream is, //\n+                                    Charset charset, //\n+                                    Type type, //\n+                                    ParserConfig config, //\n+                                    ParseProcess processor, //\n+                                    int featureValues, //\n+                                    Feature... features) throws IOException {\n+        if (charset == null) {\n+            charset = IOUtils.UTF8;\n+        }\n+\n+        byte[] bytes = allocateBytes(1024 * 64);\n+        int offset = 0;\n+        for (;;) {\n+            int readCount = is.read(bytes, offset, bytes.length - offset);\n+            if (readCount == -1) {\n+                break;\n+            }\n+            offset += readCount;\n+            if (offset == bytes.length) {\n+                byte[] newBytes = new byte[bytes.length * 3 / 2];\n+                System.arraycopy(bytes, 0, newBytes, 0, bytes.length);\n+                bytes = newBytes;\n+            }\n+        }\n+\n+        return (T) parseObject(bytes, 0, offset, charset, type, config, processor, featureValues, features);\n+    }\n+\n+    public static <T> T parseObject(String text, Class<T> clazz) {\n+        return parseObject(text, clazz, new Feature[0]);\n+    }\n+\n+    public static JSONArray parseArray(String text) {\n+        return parseArray(text, ParserConfig.global);\n+    }\n+\n+    public static JSONArray parseArray(String text, ParserConfig parserConfig) {\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        DefaultJSONParser parser = new DefaultJSONParser(text, parserConfig);\n+\n+        JSONArray array;\n+\n+        JSONLexer lexer = parser.lexer;\n+        if (lexer.token() == JSONToken.NULL) {\n+            lexer.nextToken();\n+            array = null;\n+        } else if (lexer.token() == JSONToken.EOF) {\n+            array = null;\n+        } else {\n+            array = new JSONArray();\n+            parser.parseArray(array);\n+\n+            parser.handleResovleTask(array);\n+        }\n+\n+        parser.close();\n+\n+        return array;\n+    }\n+\n+    public static <T> List<T> parseArray(String text, Class<T> clazz) {\n+        return parseArray(text, clazz, ParserConfig.global);\n+    }\n+\n+    public static <T> List<T> parseArray(String text, Class<T> clazz, ParserConfig config) {\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        List<T> list;\n+\n+        DefaultJSONParser parser = new DefaultJSONParser(text, config);\n+        JSONLexer lexer = parser.lexer;\n+        int token = lexer.token();\n+        if (token == JSONToken.NULL) {\n+            lexer.nextToken();\n+            list = null;\n+        } else if (token == JSONToken.EOF && lexer.isBlankInput()) {\n+            list = null;\n+        } else {\n+            list = new ArrayList<T>();\n+            parser.parseArray(clazz, list);\n+\n+            parser.handleResovleTask(list);\n+        }\n+\n+        parser.close();\n+\n+        return list;\n+    }\n+\n+    public static List<Object> parseArray(String text, Type[] types) {\n+        return parseArray(text, types, ParserConfig.global);\n+    }\n+\n+    public static List<Object> parseArray(String text, Type[] types, ParserConfig config) {\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        List<Object> list;\n+\n+        DefaultJSONParser parser = new DefaultJSONParser(text, config);\n+        Object[] objectArray = parser.parseArray(types);\n+        if (objectArray == null) {\n+            list = null;\n+        } else {\n+            list = Arrays.asList(objectArray);\n+        }\n+\n+        parser.handleResovleTask(list);\n+\n+        parser.close();\n+\n+        return list;\n+    }\n+\n+    /**\n+     * This method serializes the specified object into its equivalent Json representation. Note that this method works fine if the any of the object fields are of generic type,\n+     * just the object itself should not be of a generic type. If you want to write out the object to a\n+     * {@link Writer}, use {@link #writeJSONString(Writer, Object, SerializerFeature[])} instead.\n+     *\n+     * @param object the object for which json representation is to be created setting for fastjson\n+     * @return Json representation of {@code object}.\n+     */\n+    public static String toJSONString(Object object) {\n+        return toJSONString(object, emptyFilters);\n+    }\n+\n+    public static String toJSONString(Object object, SerializerFeature... features) {\n+        return toJSONString(object, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+    \n+    /**\n+     * @since 1.2.11\n+     */\n+    public static String toJSONString(Object object, int defaultFeatures, SerializerFeature... features) {\n+        SerializeWriter out = new SerializeWriter((Writer) null, defaultFeatures, features);\n+\n+        try {\n+            JSONSerializer serializer = new JSONSerializer(out);\n+            serializer.write(object);\n+            String outString = out.toString();\n+            int len = outString.length();\n+            if (len > 0\n+                    && outString.charAt(len -1) == '.'\n+                    && object instanceof Number\n+                    && !out.isEnabled(SerializerFeature.WriteClassName)) {\n+                return outString.substring(0, len - 1);\n+            }\n+            return outString;\n+        } finally {\n+            out.close();\n+        }\n+    }\n+\n+    /**\n+     * @since 1.1.14\n+     */\n+    public static String toJSONStringWithDateFormat(Object object, String dateFormat,\n+                                                          SerializerFeature... features) {\n+        return toJSONString(object, SerializeConfig.globalInstance, null, dateFormat, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+\n+    public static String toJSONString(Object object, SerializeFilter filter, SerializerFeature... features) {\n+        return toJSONString(object, SerializeConfig.globalInstance, new SerializeFilter[] {filter}, null, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+\n+    public static String toJSONString(Object object, SerializeFilter[] filters, SerializerFeature... features) {\n+        return toJSONString(object, SerializeConfig.globalInstance, filters, null, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+\n+    public static byte[] toJSONBytes(Object object, SerializerFeature... features) {\n+        return toJSONBytes(object, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+\n+    public static byte[] toJSONBytes(Object object, SerializeFilter filter, SerializerFeature... features) {\n+        return toJSONBytes(object, SerializeConfig.globalInstance, new SerializeFilter[] {filter}, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+    \n+    /**\n+     * @since 1.2.11 \n+     */\n+    public static byte[] toJSONBytes(Object object, int defaultFeatures, SerializerFeature... features) {\n+        return toJSONBytes(object, SerializeConfig.globalInstance, defaultFeatures, features);\n+    }\n+\n+    public static String toJSONString(Object object, SerializeConfig config, SerializerFeature... features) {\n+        return toJSONString(object, config, (SerializeFilter) null, features);\n+    }\n+\n+    public static String toJSONString(Object object, //\n+                                      SerializeConfig config, //\n+                                      SerializeFilter filter, //\n+                                      SerializerFeature... features) {\n+        return toJSONString(object, config, new SerializeFilter[] {filter}, null, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+\n+    public static String toJSONString(Object object, //\n+                                      SerializeConfig config, //\n+                                      SerializeFilter[] filters, //\n+                                      SerializerFeature... features) {\n+        return toJSONString(object, config, filters, null, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+    \n+    /**\n+     * @since 1.2.9\n+     * @return\n+     */\n+    public static String toJSONString(Object object, // \n+                                      SerializeConfig config, // \n+                                      SerializeFilter[] filters, // \n+                                      String dateFormat, //\n+                                      int defaultFeatures, // \n+                                      SerializerFeature... features) {\n+        SerializeWriter out = new SerializeWriter(null, defaultFeatures, features);\n+\n+        try {\n+            JSONSerializer serializer = new JSONSerializer(out, config);\n+            \n+            if (dateFormat != null && dateFormat.length() != 0) {\n+                serializer.setDateFormat(dateFormat);\n+                serializer.config(SerializerFeature.WriteDateUseDateFormat, true);\n+            }\n+\n+            if (filters != null) {\n+                for (SerializeFilter filter : filters) {\n+                    serializer.addFilter(filter);\n+                }\n+            }\n+\n+            serializer.write(object);\n+\n+            return out.toString();\n+        } finally {\n+            out.close();\n+        }\n+    }\n+\n+    /**\n+     * @deprecated\n+     */\n+    public static String toJSONStringZ(Object object, SerializeConfig mapping, SerializerFeature... features) {\n+        return toJSONString(object, mapping, emptyFilters, null, 0, features);\n+    }\n+\n+    /**\n+     * @since 1.2.42\n+     */\n+    public static byte[] toJSONBytes(Object object, SerializeConfig config, SerializerFeature... features) {\n+        return toJSONBytes(object, config, emptyFilters, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+\n+    /**\n+     * @since 1.2.11\n+     */\n+    public static byte[] toJSONBytes(Object object, SerializeConfig config, int defaultFeatures, SerializerFeature... features) {\n+        return toJSONBytes(object, config, emptyFilters, defaultFeatures, features);\n+    }\n+\n+    /**\n+     * @since 1.2.42\n+     */\n+    public static byte[] toJSONBytes(Object object, SerializeFilter[] filters, SerializerFeature... features) {\n+        return toJSONBytes(object, SerializeConfig.globalInstance, filters, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+\n+    public static byte[] toJSONBytes(Object object, SerializeConfig config, SerializeFilter filter, SerializerFeature... features) {\n+        return toJSONBytes(object, config, new SerializeFilter[] {filter}, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+    \n+    /**\n+     * @since 1.2.42\n+     */\n+    public static byte[] toJSONBytes(Object object, SerializeConfig config, SerializeFilter[] filters, int defaultFeatures, SerializerFeature... features) {\n+        return toJSONBytes(object, config, filters, null, defaultFeatures, features);\n+    }\n+\n+    /**\n+     * @since 1.2.55\n+     */\n+    public static byte[] toJSONBytes(Object object, SerializeConfig config, SerializeFilter[] filters, String dateFormat, int defaultFeatures, SerializerFeature... features) {\n+        return toJSONBytes(IOUtils.UTF8, object, config, filters, dateFormat, defaultFeatures, features);\n+    }\n+\n+    /**\n+     * @since 1.2.55\n+     */\n+    public static byte[] toJSONBytes(Charset charset, //\n+                                     Object object, //\n+                                     SerializeConfig config, //\n+                                     SerializeFilter[] filters, //\n+                                     String dateFormat, //\n+                                     int defaultFeatures, //\n+                                     SerializerFeature... features) {\n+        SerializeWriter out = new SerializeWriter(null, defaultFeatures, features);\n+\n+        try {\n+            JSONSerializer serializer = new JSONSerializer(out, config);\n+\n+            if (dateFormat != null && dateFormat.length() != 0) {\n+                serializer.setDateFormat(dateFormat);\n+                serializer.config(SerializerFeature.WriteDateUseDateFormat, true);\n+            }\n+\n+            if (filters != null) {\n+                for (SerializeFilter filter : filters) {\n+                    serializer.addFilter(filter);\n+                }\n+            }\n+\n+            serializer.write(object);\n+            return out.toBytes(charset);\n+        } finally {\n+            out.close();\n+        }\n+    }\n+\n+    /**\n+     * Use the date format in FastJsonConfig to serialize JSON\n+     *\n+     * @param  dateFormat the date format in FastJsonConfigs\n+     * @since 1.2.55\n+     */\n+    public static byte[] toJSONBytesWithFastJsonConfig(Charset charset, //\n+                                     Object object, //\n+                                     SerializeConfig config, //\n+                                     SerializeFilter[] filters, //\n+                                     String dateFormat, //\n+                                     int defaultFeatures, //\n+                                     SerializerFeature... features) {\n+        SerializeWriter out = new SerializeWriter(null, defaultFeatures, features);\n+\n+        try {\n+            JSONSerializer serializer = new JSONSerializer(out, config);\n+\n+            if (dateFormat != null && dateFormat.length() != 0) {\n+                serializer.setFastJsonConfigDateFormatPattern(dateFormat);\n+                serializer.config(SerializerFeature.WriteDateUseDateFormat, true);\n+            }\n+\n+            if (filters != null) {\n+                for (SerializeFilter filter : filters) {\n+                    serializer.addFilter(filter);\n+                }\n+            }\n+\n+            serializer.write(object);\n+            return out.toBytes(charset);\n+        } finally {\n+            out.close();\n+        }\n+    }\n+\n+    public static String toJSONString(Object object, boolean prettyFormat) {\n+        if (!prettyFormat) {\n+            return toJSONString(object);\n+        }\n+\n+        return toJSONString(object, SerializerFeature.PrettyFormat);\n+    }\n+    \n+    /**\n+     * @deprecated use writeJSONString\n+     */\n+    public static void writeJSONStringTo(Object object, Writer writer, SerializerFeature... features) {\n+        writeJSONString(writer, object, features);\n+    }\n+\n+    /**\n+     * This method serializes the specified object into its equivalent json representation.\n+     *\n+     * @param writer Writer to which the json representation needs to be written\n+     * @param object the object for which json representation is to be created setting for fastjson\n+     * @param features serializer features\n+     * @since 1.2.11\n+     */\n+    public static void writeJSONString(Writer writer, Object object, SerializerFeature... features) {\n+        writeJSONString(writer, object, JSON.DEFAULT_GENERATE_FEATURE, features);\n+    }\n+    \n+    /**\n+     * @since 1.2.11 \n+     */\n+    public static void writeJSONString(Writer writer, Object object, int defaultFeatures, SerializerFeature... features) {\n+        SerializeWriter out = new SerializeWriter(writer, defaultFeatures, features);\n+\n+        try {\n+            JSONSerializer serializer = new JSONSerializer(out);\n+            serializer.write(object);\n+        } finally {\n+            out.close();\n+        }\n+    }\n+    \n+    /**\n+     * write object as json to OutputStream\n+     * @param os output stream\n+     * @param object\n+     * @param features serializer features\n+     * @since 1.2.11\n+     * @throws IOException\n+     */\n+    public static final int writeJSONString(OutputStream os, // \n+                                             Object object, // \n+                                             SerializerFeature... features) throws IOException {\n+        return writeJSONString(os, object, DEFAULT_GENERATE_FEATURE, features);\n+    }\n+    \n+    /**\n+     * @since 1.2.11 \n+     */\n+    public static final int writeJSONString(OutputStream os, // \n+                                            Object object, // \n+                                            int defaultFeatures, //\n+                                            SerializerFeature... features) throws IOException {\n+       return writeJSONString(os,  //\n+                              IOUtils.UTF8, //\n+                              object, //\n+                              SerializeConfig.globalInstance, //\n+                              null, //\n+                              null, // \n+                              defaultFeatures, //\n+                              features);\n+   }\n+    \n+    public static final int writeJSONString(OutputStream os, // \n+                                             Charset charset, // \n+                                             Object object, // \n+                                             SerializerFeature... features) throws IOException {\n+        return writeJSONString(os, //\n+                               charset, //\n+                               object, //\n+                               SerializeConfig.globalInstance, //\n+                               null, //\n+                               null, //\n+                               DEFAULT_GENERATE_FEATURE, //\n+                               features);\n+    }\n+    \n+    public static final int writeJSONString(OutputStream os, // \n+                                             Charset charset, // \n+                                             Object object, // \n+                                             SerializeConfig config, //\n+                                             SerializeFilter[] filters, //\n+                                             String dateFormat, //\n+                                             int defaultFeatures, //\n+                                             SerializerFeature... features) throws IOException {\n+        SerializeWriter writer = new SerializeWriter(null, defaultFeatures, features);\n+\n+        try {\n+            JSONSerializer serializer = new JSONSerializer(writer, config);\n+            \n+            if (dateFormat != null && dateFormat.length() != 0) {\n+                serializer.setDateFormat(dateFormat);\n+                serializer.config(SerializerFeature.WriteDateUseDateFormat, true);\n+            }\n+\n+            if (filters != null) {\n+                for (SerializeFilter filter : filters) {\n+                    serializer.addFilter(filter);\n+                }\n+            }\n+            \n+            serializer.write(object);\n+            \n+            int len = writer.writeToEx(os, charset);\n+            return len;\n+        } finally {\n+            writer.close();\n+        }\n+    }\n+\n+    public static final int writeJSONStringWithFastJsonConfig(OutputStream os, //\n+                                            Charset charset, //\n+                                            Object object, //\n+                                            SerializeConfig config, //\n+                                            SerializeFilter[] filters, //\n+                                            String dateFormat, //\n+                                            int defaultFeatures, //\n+                                            SerializerFeature... features) throws IOException {\n+        SerializeWriter writer = new SerializeWriter(null, defaultFeatures, features);\n+\n+        try {\n+            JSONSerializer serializer = new JSONSerializer(writer, config);\n+\n+            if (dateFormat != null && dateFormat.length() != 0) {\n+                serializer.setFastJsonConfigDateFormatPattern(dateFormat);\n+                serializer.config(SerializerFeature.WriteDateUseDateFormat, true);\n+            }\n+\n+            if (filters != null) {\n+                for (SerializeFilter filter : filters) {\n+                    serializer.addFilter(filter);\n+                }\n+            }\n+\n+            serializer.write(object);\n+\n+            int len = writer.writeToEx(os, charset);\n+            return len;\n+        } finally {\n+            writer.close();\n+        }\n+    }\n+\n+    // ======================================\n+    @Override\n+    public String toString() {\n+        return toJSONString();\n+    }\n+\n+    public String toJSONString() {\n+        SerializeWriter out = new SerializeWriter();\n+        try {\n+            new JSONSerializer(out).write(this);\n+            return out.toString();\n+        } finally {\n+            out.close();\n+        }\n+    }\n+\n+    /**\n+     * @since 1.2.57\n+     */\n+    public String toString(SerializerFeature... features) {\n+        SerializeWriter out = new SerializeWriter(null, JSON.DEFAULT_GENERATE_FEATURE, features);\n+\n+        try {\n+            new JSONSerializer(out).write(this);\n+            return out.toString();\n+        } finally {\n+            out.close();\n+        }\n+    }\n+\n+    public void writeJSONString(Appendable appendable) {\n+        SerializeWriter out = new SerializeWriter();\n+        try {\n+            new JSONSerializer(out).write(this);\n+            appendable.append(out.toString());\n+        } catch (IOException e) {\n+            throw new JSONException(e.getMessage(), e);\n+        } finally {\n+            out.close();\n+        }\n+    }\n+\n+    /**\n+     * This method serializes the specified object into its equivalent representation as a tree of\n+     * {@link JSONObject}s. \n+     *\n+     */\n+    public static Object toJSON(Object javaObject) {\n+        return toJSON(javaObject, SerializeConfig.globalInstance);\n+    }\n+\n+    /**\n+     * @deprecated\n+     */\n+    public static Object toJSON(Object javaObject, ParserConfig parserConfig) {\n+        return toJSON(javaObject, SerializeConfig.globalInstance);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public static Object toJSON(Object javaObject, SerializeConfig config) {\n+        if (javaObject == null) {\n+            return null;\n+        }\n+\n+        if (javaObject instanceof JSON) {\n+            return javaObject;\n+        }\n+\n+        if (javaObject instanceof Map) {\n+            Map<Object, Object> map = (Map<Object, Object>) javaObject;\n+\n+            int size = map.size();\n+\n+            Map innerMap;\n+            if (map instanceof LinkedHashMap) {\n+                innerMap = new LinkedHashMap(size);\n+            } else if (map instanceof TreeMap) {\n+                innerMap = new TreeMap();\n+            } else {\n+                innerMap = new HashMap(size);\n+            }\n+\n+            JSONObject json = new JSONObject(innerMap);\n+\n+            for (Map.Entry<Object, Object> entry : map.entrySet()) {\n+                Object key = entry.getKey();\n+                String jsonKey = TypeUtils.castToString(key);\n+                Object jsonValue = toJSON(entry.getValue(), config);\n+                json.put(jsonKey, jsonValue);\n+            }\n+\n+            return json;\n+        }\n+\n+        if (javaObject instanceof Collection) {\n+            Collection<Object> collection = (Collection<Object>) javaObject;\n+\n+            JSONArray array = new JSONArray(collection.size());\n+\n+            for (Object item : collection) {\n+                Object jsonValue = toJSON(item, config);\n+                array.add(jsonValue);\n+            }\n+\n+            return array;\n+        }\n+\n+        if (javaObject instanceof JSONSerializable) {\n+            String json = JSON.toJSONString(javaObject);\n+            return JSON.parse(json);\n+        }\n+\n+        Class<?> clazz = javaObject.getClass();\n+\n+        if (clazz.isEnum()) {\n+            return ((Enum<?>) javaObject).name();\n+        }\n+\n+        if (clazz.isArray()) {\n+            int len = Array.getLength(javaObject);\n+\n+            JSONArray array = new JSONArray(len);\n+\n+            for (int i = 0; i < len; ++i) {\n+                Object item = Array.get(javaObject, i);\n+                Object jsonValue = toJSON(item);\n+                array.add(jsonValue);\n+            }\n+\n+            return array;\n+        }\n+\n+        if (ParserConfig.isPrimitive2(clazz)) {\n+            return javaObject;\n+        }\n+\n+        ObjectSerializer serializer = config.getObjectWriter(clazz);\n+        if (serializer instanceof JavaBeanSerializer) {\n+            JavaBeanSerializer javaBeanSerializer = (JavaBeanSerializer) serializer;\n+\n+            JSONType jsonType = javaBeanSerializer.getJSONType();\n+            boolean ordered = false;\n+            if (jsonType != null) {\n+                for (SerializerFeature serializerFeature : jsonType.serialzeFeatures()) {\n+                    if (serializerFeature == SerializerFeature.SortField\n+                            || serializerFeature == SerializerFeature.MapSortField) {\n+                        ordered = true;\n+                    }\n+                }\n+            }\n+\n+            JSONObject json = new JSONObject(ordered);\n+            try {\n+                Map<String, Object> values = javaBeanSerializer.getFieldValuesMap(javaObject);\n+                for (Map.Entry<String, Object> entry : values.entrySet()) {\n+                    json.put(entry.getKey(), toJSON(entry.getValue(), config));\n+                }\n+            } catch (Exception e) {\n+                throw new JSONException(\"toJSON error\", e);\n+            }\n+            return json;\n+        }\n+        \n+        String text = JSON.toJSONString(javaObject, config);\n+        return JSON.parse(text);\n+    }\n+\n+    public static <T> T toJavaObject(JSON json, Class<T> clazz) {\n+        return TypeUtils.cast(json, clazz, ParserConfig.getGlobalInstance());\n+    }\n+    \n+    /**\n+     * @since 1.2.9\n+     */\n+    public <T> T toJavaObject(Class<T> clazz) {\n+        if (clazz == JSONArray.class || clazz == JSON.class || clazz == Collection.class || clazz == List.class) {\n+            return (T) this;\n+        }\n+\n+        return TypeUtils.cast(this, clazz, ParserConfig.getGlobalInstance());\n+    }\n+\n+    /**\n+     * @since 1.2.33\n+     */\n+    public <T> T toJavaObject(Type type) {\n+        return TypeUtils.cast(this, type, ParserConfig.getGlobalInstance());\n+    }\n+\n+    /**\n+     * @since 1.2.33\n+     */\n+    public <T> T toJavaObject(TypeReference typeReference) {\n+        Type type = typeReference != null ? typeReference.getType() : null;\n+        return TypeUtils.cast(this, type, ParserConfig.getGlobalInstance());\n+    }\n+    \n+    private final static ThreadLocal<byte[]> bytesLocal = new ThreadLocal<byte[]>();\n+    private static byte[] allocateBytes(int length) {\n+        byte[] chars = bytesLocal.get();\n+\n+        if (chars == null) {\n+            if (length <= 1024 * 64) {\n+                chars = new byte[1024 * 64];\n+                bytesLocal.set(chars);\n+            } else {\n+                chars = new byte[length];\n+            }\n+        } else if (chars.length < length) {\n+            chars = new byte[length];\n+        }\n+\n+        return chars;\n+    }\n+    \n+    private final static ThreadLocal<char[]> charsLocal = new ThreadLocal<char[]>();\n+    private static char[] allocateChars(int length) {\n+        char[] chars = charsLocal.get();\n+\n+        if (chars == null) {\n+            if (length <= 1024 * 64) {\n+                chars = new char[1024 * 64];\n+                charsLocal.set(chars);\n+            } else {\n+                chars = new char[length];\n+            }\n+        } else if (chars.length < length) {\n+            chars = new char[length];\n+        }\n+\n+        return chars;\n+    }\n+\n+    /**\n+     * @deprecated Please use {@link com.alibaba.fastjson.JSONValidator} instead.\n+     */\n+    public static boolean isValid(String str) {\n+        if (str == null || str.length() == 0) {\n+            return false;\n+        }\n+\n+        JSONScanner lexer = new JSONScanner(str);\n+        try {\n+            lexer.nextToken();\n+\n+            final int token = lexer.token();\n+            switch (token) {\n+                case JSONToken.LBRACE:\n+                    if (lexer.getCurrent() == JSONLexer.EOI) {\n+                        return false;\n+                    }\n+                    lexer.skipObject(true);\n+                    break;\n+                case JSONToken.LBRACKET:\n+                    lexer.skipArray(true);\n+                    break;\n+                case JSONToken.LITERAL_INT:\n+                case JSONToken.LITERAL_STRING:\n+                case JSONToken.LITERAL_FLOAT:\n+                case JSONToken.LITERAL_ISO8601_DATE:\n+                case JSONToken.NULL:\n+                case JSONToken.TRUE:\n+                case JSONToken.FALSE:\n+                    lexer.nextToken();\n+                    break;\n+                default:\n+                    return false;\n+            }\n+\n+            return lexer.token() == JSONToken.EOF;\n+        } catch (Exception ex) {\n+            return false;\n+        } finally {\n+            lexer.close();\n+        }\n+    }\n+\n+    /**\n+     * @deprecated Please use {@link com.alibaba.fastjson.JSONValidator} instead.\n+     */\n+    public static boolean isValidObject(String str) {\n+        if (str == null || str.length() == 0) {\n+            return false;\n+        }\n+\n+        JSONScanner lexer = new JSONScanner(str);\n+\n+        try {\n+            lexer.nextToken();\n+            final int token = lexer.token();\n+            if (token == JSONToken.LBRACE) {\n+                if (lexer.getCurrent() == JSONLexer.EOI) {\n+                    return false;\n+                }\n+                lexer.skipObject(true);\n+                return lexer.token() == JSONToken.EOF;\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            return false;\n+        } finally {\n+            lexer.close();\n+        }\n+    }\n+\n+    /**\n+     * @deprecated Please use {@link com.alibaba.fastjson.JSONValidator} instead.\n+     */\n+    public static boolean isValidArray(String str) {\n+        if (str == null || str.length() == 0) {\n+            return false;\n+        }\n+\n+        JSONScanner lexer = new JSONScanner(str);\n+        try {\n+            lexer.nextToken();\n+            final int token = lexer.token();\n+            if (token == JSONToken.LBRACKET) {\n+                lexer.skipArray(true);\n+                return lexer.token() == JSONToken.EOF;\n+            }\n+            return false;\n+        } catch (Exception ex) {\n+            return false;\n+        } finally {\n+            lexer.close();\n+        }\n+    }\n+\n+    public static <T> void handleResovleTask(DefaultJSONParser parser, T value) {\n+        parser.handleResovleTask(value);\n+    }\n+    \n+    public static void addMixInAnnotations(Type target, Type mixinSource) {\n+        if (target != null && mixinSource != null) {\n+            mixInsMapper.put(target, mixinSource);\n+        }\n+    }\n+\n+    public static void removeMixInAnnotations(Type target) {\n+        if (target != null) {\n+            mixInsMapper.remove(target);\n+        }\n+    }\n+\n+    public static void clearMixInAnnotations() {\n+        mixInsMapper.clear();\n+    }\n+\n+    public static Type getMixInAnnotations(Type target) {\n+        if (target != null) {\n+            return mixInsMapper.get(target);\n+        }\n+        return null;\n+    }\n+\n+    public final static String VERSION = \"1.2.76\";\n+}"},{"sha":"cdb144059766baa7ff4e2eae380f9c4c1d302bc0","filename":"src/main/java/com/alibaba/fastjson/JSONArray.java","status":"added","additions":497,"deletions":0,"changes":497,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONArray.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONArray.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONArray.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,497 @@\n+/*\r\n+ * Copyright 1999-2017 Alibaba Group.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *      http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package com.alibaba.fastjson;\r\n+\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToBigDecimal;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToBigInteger;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToBoolean;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToByte;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToDate;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToDouble;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToFloat;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToInt;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToLong;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToShort;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToSqlDate;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToString;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToTimestamp;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.Serializable;\r\n+import java.lang.reflect.Type;\r\n+import java.math.BigDecimal;\r\n+import java.math.BigInteger;\r\n+import java.util.*;\r\n+\r\n+import com.alibaba.fastjson.parser.ParserConfig;\r\n+import com.alibaba.fastjson.util.TypeUtils;\r\n+\r\n+/**\r\n+ * @author wenshao[szujobs@hotmail.com]\r\n+ */\r\n+public class JSONArray extends JSON implements List<Object>, Cloneable, RandomAccess, Serializable {\r\n+\r\n+    private static final long  serialVersionUID = 1L;\r\n+    private final List<Object> list;\r\n+    protected transient Object relatedArray;\r\n+    protected transient Type   componentType;\r\n+\r\n+    public JSONArray(){\r\n+        this.list = new ArrayList<Object>();\r\n+    }\r\n+\r\n+    public JSONArray(List<Object> list){\r\n+        if (list == null){\r\n+            throw new IllegalArgumentException(\"list is null.\");\r\n+        }\r\n+        this.list = list;\r\n+    }\r\n+\r\n+    public JSONArray(int initialCapacity){\r\n+        this.list = new ArrayList<Object>(initialCapacity);\r\n+    }\r\n+\r\n+    /**\r\n+     * @since 1.1.16\r\n+     * @return\r\n+     */\r\n+    public Object getRelatedArray() {\r\n+        return relatedArray;\r\n+    }\r\n+\r\n+    public void setRelatedArray(Object relatedArray) {\r\n+        this.relatedArray = relatedArray;\r\n+    }\r\n+\r\n+    public Type getComponentType() {\r\n+        return componentType;\r\n+    }\r\n+\r\n+    public void setComponentType(Type componentType) {\r\n+        this.componentType = componentType;\r\n+    }\r\n+\r\n+    public int size() {\r\n+        return list.size();\r\n+    }\r\n+\r\n+    public boolean isEmpty() {\r\n+        return list.isEmpty();\r\n+    }\r\n+\r\n+    public boolean contains(Object o) {\r\n+        return list.contains(o);\r\n+    }\r\n+\r\n+    public Iterator<Object> iterator() {\r\n+        return list.iterator();\r\n+    }\r\n+\r\n+    public Object[] toArray() {\r\n+        return list.toArray();\r\n+    }\r\n+\r\n+    public <T> T[] toArray(T[] a) {\r\n+        return list.toArray(a);\r\n+    }\r\n+\r\n+    public boolean add(Object e) {\r\n+        return list.add(e);\r\n+    }\r\n+\r\n+    public JSONArray fluentAdd(Object e) {\r\n+        list.add(e);\r\n+        return this;\r\n+    }\r\n+\r\n+    public boolean remove(Object o) {\r\n+        return list.remove(o);\r\n+    }\r\n+\r\n+    public JSONArray fluentRemove(Object o) {\r\n+        list.remove(o);\r\n+        return this;\r\n+    }\r\n+\r\n+    public boolean containsAll(Collection<?> c) {\r\n+        return list.containsAll(c);\r\n+    }\r\n+\r\n+    public boolean addAll(Collection<?> c) {\r\n+        return list.addAll(c);\r\n+    }\r\n+\r\n+    public JSONArray fluentAddAll(Collection<?> c) {\r\n+        list.addAll(c);\r\n+        return this;\r\n+    }\r\n+\r\n+    public boolean addAll(int index, Collection<?> c) {\r\n+        return list.addAll(index, c);\r\n+    }\r\n+\r\n+    public JSONArray fluentAddAll(int index, Collection<?> c) {\r\n+        list.addAll(index, c);\r\n+        return this;\r\n+    }\r\n+\r\n+    public boolean removeAll(Collection<?> c) {\r\n+        return list.removeAll(c);\r\n+    }\r\n+\r\n+    public JSONArray fluentRemoveAll(Collection<?> c) {\r\n+        list.removeAll(c);\r\n+        return this;\r\n+    }\r\n+\r\n+    public boolean retainAll(Collection<?> c) {\r\n+        return list.retainAll(c);\r\n+    }\r\n+\r\n+    public JSONArray fluentRetainAll(Collection<?> c) {\r\n+        list.retainAll(c);\r\n+        return this;\r\n+    }\r\n+\r\n+    public void clear() {\r\n+        list.clear();\r\n+    }\r\n+\r\n+    public JSONArray fluentClear() {\r\n+        list.clear();\r\n+        return this;\r\n+    }\r\n+\r\n+    public Object set(int index, Object element) {\r\n+        if (index == -1) {\r\n+            list.add(element);\r\n+            return null;\r\n+        }\r\n+\r\n+        if (list.size() <= index) {\r\n+            for (int i = list.size(); i < index; ++i) {\r\n+                list.add(null);\r\n+            }\r\n+            list.add(element);\r\n+            return null;\r\n+        }\r\n+\r\n+        return list.set(index, element);\r\n+    }\r\n+\r\n+    public JSONArray fluentSet(int index, Object element) {\r\n+        set(index, element);\r\n+        return this;\r\n+    }\r\n+\r\n+    public void add(int index, Object element) {\r\n+        list.add(index, element);\r\n+    }\r\n+\r\n+    public JSONArray fluentAdd(int index, Object element) {\r\n+        list.add(index, element);\r\n+        return this;\r\n+    }\r\n+\r\n+    public Object remove(int index) {\r\n+        return list.remove(index);\r\n+    }\r\n+\r\n+    public JSONArray fluentRemove(int index) {\r\n+        list.remove(index);\r\n+        return this;\r\n+    }\r\n+\r\n+    public int indexOf(Object o) {\r\n+        return list.indexOf(o);\r\n+    }\r\n+\r\n+    public int lastIndexOf(Object o) {\r\n+        return list.lastIndexOf(o);\r\n+    }\r\n+\r\n+    public ListIterator<Object> listIterator() {\r\n+        return list.listIterator();\r\n+    }\r\n+\r\n+    public ListIterator<Object> listIterator(int index) {\r\n+        return list.listIterator(index);\r\n+    }\r\n+\r\n+    public List<Object> subList(int fromIndex, int toIndex) {\r\n+        return list.subList(fromIndex, toIndex);\r\n+    }\r\n+\r\n+    public Object get(int index) {\r\n+        return list.get(index);\r\n+    }\r\n+\r\n+    public JSONObject getJSONObject(int index) {\r\n+        Object value = list.get(index);\r\n+\r\n+        if (value instanceof JSONObject) {\r\n+            return (JSONObject) value;\r\n+        }\r\n+\r\n+        if (value instanceof Map) {\r\n+            return new JSONObject((Map) value);\r\n+        }\r\n+\r\n+        return (JSONObject) toJSON(value);\r\n+    }\r\n+\r\n+    public JSONArray getJSONArray(int index) {\r\n+        Object value = list.get(index);\r\n+\r\n+        if (value instanceof JSONArray) {\r\n+            return (JSONArray) value;\r\n+        }\r\n+\r\n+        if (value instanceof List) {\r\n+            return new JSONArray((List) value);\r\n+        }\r\n+\r\n+        return (JSONArray) toJSON(value);\r\n+    }\r\n+\r\n+    public <T> T getObject(int index, Class<T> clazz) {\r\n+        Object obj = list.get(index);\r\n+        return TypeUtils.castToJavaBean(obj, clazz);\r\n+    }\r\n+\r\n+    public <T> T getObject(int index, Type type) {\r\n+        Object obj = list.get(index);\r\n+        if (type instanceof Class) {\r\n+            return (T) TypeUtils.castToJavaBean(obj, (Class) type);\r\n+        } else {\r\n+            String json = JSON.toJSONString(obj);\r\n+            return (T) JSON.parseObject(json, type);\r\n+        }\r\n+    }\r\n+\r\n+    public Boolean getBoolean(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        if (value == null) {\r\n+            return null;\r\n+        }\r\n+\r\n+        return castToBoolean(value);\r\n+    }\r\n+\r\n+    public boolean getBooleanValue(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        if (value == null) {\r\n+            return false;\r\n+        }\r\n+\r\n+        return castToBoolean(value).booleanValue();\r\n+    }\r\n+\r\n+    public Byte getByte(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToByte(value);\r\n+    }\r\n+\r\n+    public byte getByteValue(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        Byte byteVal = castToByte(value);\r\n+        if (byteVal == null) {\r\n+            return 0;\r\n+        }\r\n+\r\n+        return byteVal.byteValue();\r\n+    }\r\n+\r\n+    public Short getShort(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToShort(value);\r\n+    }\r\n+\r\n+    public short getShortValue(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        Short shortVal = castToShort(value);\r\n+        if (shortVal == null) {\r\n+            return 0;\r\n+        }\r\n+\r\n+        return shortVal.shortValue();\r\n+    }\r\n+\r\n+    public Integer getInteger(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToInt(value);\r\n+    }\r\n+\r\n+    public int getIntValue(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        Integer intVal = castToInt(value);\r\n+        if (intVal == null) {\r\n+            return 0;\r\n+        }\r\n+\r\n+        return intVal.intValue();\r\n+    }\r\n+\r\n+    public Long getLong(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToLong(value);\r\n+    }\r\n+\r\n+    public long getLongValue(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        Long longVal = castToLong(value);\r\n+        if (longVal == null) {\r\n+            return 0L;\r\n+        }\r\n+\r\n+        return longVal.longValue();\r\n+    }\r\n+\r\n+    public Float getFloat(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToFloat(value);\r\n+    }\r\n+\r\n+    public float getFloatValue(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        Float floatValue = castToFloat(value);\r\n+        if (floatValue == null) {\r\n+            return 0F;\r\n+        }\r\n+\r\n+        return floatValue.floatValue();\r\n+    }\r\n+\r\n+    public Double getDouble(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToDouble(value);\r\n+    }\r\n+\r\n+    public double getDoubleValue(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        Double doubleValue = castToDouble(value);\r\n+        if (doubleValue == null) {\r\n+            return 0D;\r\n+        }\r\n+\r\n+        return doubleValue.doubleValue();\r\n+    }\r\n+\r\n+    public BigDecimal getBigDecimal(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToBigDecimal(value);\r\n+    }\r\n+\r\n+    public BigInteger getBigInteger(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToBigInteger(value);\r\n+    }\r\n+\r\n+    public String getString(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToString(value);\r\n+    }\r\n+\r\n+    public java.util.Date getDate(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToDate(value);\r\n+    }\r\n+\r\n+    public java.sql.Date getSqlDate(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToSqlDate(value);\r\n+    }\r\n+\r\n+    public java.sql.Timestamp getTimestamp(int index) {\r\n+        Object value = get(index);\r\n+\r\n+        return castToTimestamp(value);\r\n+    }\r\n+\r\n+    /**\r\n+     * @since  1.2.23\r\n+     */\r\n+    public <T> List<T> toJavaList(Class<T> clazz) {\r\n+        List<T> list = new ArrayList<T>(this.size());\r\n+\r\n+        ParserConfig config = ParserConfig.getGlobalInstance();\r\n+\r\n+        for (Object item : this) {\r\n+            T classItem = (T) TypeUtils.cast(item, clazz, config);\r\n+            list.add(classItem);\r\n+        }\r\n+\r\n+        return list;\r\n+    }\r\n+\r\n+    @Override\r\n+    public Object clone() {\r\n+        return new JSONArray(new ArrayList<Object>(list));\r\n+    }\r\n+\r\n+    public boolean equals(Object obj) {\r\n+        return this.list.equals(obj);\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return this.list.hashCode();\r\n+    }\r\n+\r\n+    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {\r\n+        JSONObject.SecureObjectInputStream.ensureFields();\r\n+        if (JSONObject.SecureObjectInputStream.fields != null && !JSONObject.SecureObjectInputStream.fields_error) {\r\n+            ObjectInputStream secIn = new JSONObject.SecureObjectInputStream(in);\r\n+            try {\r\n+                secIn.defaultReadObject();\r\n+                return;\r\n+            } catch (java.io.NotActiveException e) {\r\n+                // skip\r\n+            }\r\n+        }\r\n+\r\n+        in.defaultReadObject();\r\n+        for (Object item : list) {\r\n+            if (item == null) {\r\n+                continue;\r\n+            }\r\n+\r\n+            String typeName = item.getClass().getName();\r\n+            if (TypeUtils.getClassFromMapping(typeName) == null) {\r\n+                ParserConfig.global.checkAutoType(typeName, null);\r\n+            }\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"b552548fbe634ecd1cc34036b964063b00e0ffb1","filename":"src/main/java/com/alibaba/fastjson/JSONAware.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONAware.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONAware.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONAware.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,29 @@\n+/*\r\n+ * Copyright 1999-2017 Alibaba Group.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *      http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package com.alibaba.fastjson;\r\n+\r\n+/**\r\n+ * Beans that support customized output of JSON text shall implement this interface.\r\n+ * \r\n+ * @author wenshao[szujobs@hotmail.com]\r\n+ */\r\n+public interface JSONAware {\r\n+\r\n+    /**\r\n+     * @return JSON text\r\n+     */\r\n+    String toJSONString();\r\n+}\r"},{"sha":"f225de337cc9a2a33ed7dbdb1497eb1527557fa2","filename":"src/main/java/com/alibaba/fastjson/JSONException.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONException.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONException.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONException.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,35 @@\n+/*\r\n+ * Copyright 1999-2019 Alibaba Group.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *      http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package com.alibaba.fastjson;\r\n+\r\n+/**\r\n+ * @author wenshao[szujobs@hotmail.com]\r\n+ */\r\n+@SuppressWarnings(\"serial\")\r\n+public class JSONException extends RuntimeException {\r\n+\r\n+    public JSONException() {\r\n+        super();\r\n+    }\r\n+\r\n+    public JSONException(String message) {\r\n+        super(message);\r\n+    }\r\n+\r\n+    public JSONException(String message, Throwable cause) {\r\n+        super(message, cause);\r\n+    }\r\n+}\r"},{"sha":"5a42425cfd9b8942180f029428374bea2d5be0fb","filename":"src/main/java/com/alibaba/fastjson/JSONObject.java","status":"added","additions":628,"deletions":0,"changes":628,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONObject.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONObject.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONObject.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,628 @@\n+/*\r\n+ * Copyright 1999-2017 Alibaba Group.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *      http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package com.alibaba.fastjson;\r\n+\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToBigDecimal;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToBigInteger;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToBoolean;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToByte;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToBytes;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToDate;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToDouble;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToFloat;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToInt;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToLong;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToShort;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToSqlDate;\r\n+import static com.alibaba.fastjson.util.TypeUtils.castToTimestamp;\r\n+\r\n+import java.io.*;\r\n+import java.lang.reflect.Field;\r\n+import java.lang.reflect.InvocationHandler;\r\n+import java.lang.reflect.Method;\r\n+import java.lang.reflect.Type;\r\n+import java.math.BigDecimal;\r\n+import java.math.BigInteger;\r\n+import java.util.*;\r\n+\r\n+import com.alibaba.fastjson.annotation.JSONField;\r\n+import com.alibaba.fastjson.parser.Feature;\r\n+import com.alibaba.fastjson.parser.ParserConfig;\r\n+import com.alibaba.fastjson.util.TypeUtils;\r\n+\r\n+/**\r\n+ * @author wenshao[szujobs@hotmail.com]\r\n+ */\r\n+public class JSONObject extends JSON implements Map<String, Object>, Cloneable, Serializable, InvocationHandler {\r\n+\r\n+    private static final long         serialVersionUID         = 1L;\r\n+    private static final int          DEFAULT_INITIAL_CAPACITY = 16;\r\n+\r\n+    private final Map<String, Object> map;\r\n+\r\n+    public JSONObject(){\r\n+        this(DEFAULT_INITIAL_CAPACITY, false);\r\n+    }\r\n+\r\n+    public JSONObject(Map<String, Object> map){\r\n+        if (map == null) {\r\n+            throw new IllegalArgumentException(\"map is null.\");\r\n+        }\r\n+        this.map = map;\r\n+    }\r\n+\r\n+    public JSONObject(boolean ordered){\r\n+        this(DEFAULT_INITIAL_CAPACITY, ordered);\r\n+    }\r\n+\r\n+    public JSONObject(int initialCapacity){\r\n+        this(initialCapacity, false);\r\n+    }\r\n+\r\n+    public JSONObject(int initialCapacity, boolean ordered){\r\n+        if (ordered) {\r\n+            map = new LinkedHashMap<String, Object>(initialCapacity);\r\n+        } else {\r\n+            map = new HashMap<String, Object>(initialCapacity);\r\n+        }\r\n+    }\r\n+\r\n+    public int size() {\r\n+        return map.size();\r\n+    }\r\n+\r\n+    public boolean isEmpty() {\r\n+        return map.isEmpty();\r\n+    }\r\n+\r\n+    public boolean containsKey(Object key) {\r\n+        boolean result = map.containsKey(key);\r\n+        if (!result) {\r\n+            if (key instanceof Number\r\n+                    || key instanceof Character\r\n+                    || key instanceof Boolean\r\n+                    || key instanceof UUID\r\n+            ) {\r\n+                result = map.containsKey(key.toString());\r\n+            }\r\n+        }\r\n+        return result;\r\n+    }\r\n+\r\n+    public boolean containsValue(Object value) {\r\n+        return map.containsValue(value);\r\n+    }\r\n+\r\n+    public Object get(Object key) {\r\n+        Object val = map.get(key);\r\n+\r\n+        if (val == null) {\r\n+            if (key instanceof Number\r\n+                    || key instanceof Character\r\n+                    || key instanceof Boolean\r\n+                    || key instanceof UUID\r\n+            ) {\r\n+                val = map.get(key.toString());\r\n+            }\r\n+        }\r\n+\r\n+        return val;\r\n+    }\r\n+\r\n+    public JSONObject getJSONObject(String key) {\r\n+        Object value = map.get(key);\r\n+\r\n+        if (value instanceof JSONObject) {\r\n+            return (JSONObject) value;\r\n+        }\r\n+\r\n+        if (value instanceof Map) {\r\n+            return new JSONObject((Map) value);\r\n+        }\r\n+\r\n+        if (value instanceof String) {\r\n+            return JSON.parseObject((String) value);\r\n+        }\r\n+\r\n+        return (JSONObject) toJSON(value);\r\n+    }\r\n+\r\n+    public JSONArray getJSONArray(String key) {\r\n+        Object value = map.get(key);\r\n+\r\n+        if (value instanceof JSONArray) {\r\n+            return (JSONArray) value;\r\n+        }\r\n+\r\n+        if (value instanceof List) {\r\n+            return new JSONArray((List) value);\r\n+        }\r\n+\r\n+        if (value instanceof String) {\r\n+            return (JSONArray) JSON.parse((String) value);\r\n+        }\r\n+\r\n+        return (JSONArray) toJSON(value);\r\n+    }\r\n+\r\n+    public <T> T getObject(String key, Class<T> clazz) {\r\n+        Object obj = map.get(key);\r\n+        return TypeUtils.castToJavaBean(obj, clazz);\r\n+    }\r\n+\r\n+    public <T> T getObject(String key, Type type) {\r\n+        Object obj = map.get(key);\r\n+        return TypeUtils.cast(obj, type, ParserConfig.getGlobalInstance());\r\n+    }\r\n+\r\n+    public <T> T getObject(String key, TypeReference typeReference) {\r\n+        Object obj = map.get(key);\r\n+        if (typeReference == null) {\r\n+            return (T) obj;\r\n+        }\r\n+        return TypeUtils.cast(obj, typeReference.getType(), ParserConfig.getGlobalInstance());\r\n+    }\r\n+\r\n+    public Boolean getBoolean(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        if (value == null) {\r\n+            return null;\r\n+        }\r\n+\r\n+        return castToBoolean(value);\r\n+    }\r\n+\r\n+    public byte[] getBytes(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        if (value == null) {\r\n+            return null;\r\n+        }\r\n+\r\n+        return castToBytes(value);\r\n+    }\r\n+\r\n+    public boolean getBooleanValue(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        Boolean booleanVal = castToBoolean(value);\r\n+        if (booleanVal == null) {\r\n+            return false;\r\n+        }\r\n+\r\n+        return booleanVal.booleanValue();\r\n+    }\r\n+\r\n+    public Byte getByte(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToByte(value);\r\n+    }\r\n+\r\n+    public byte getByteValue(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        Byte byteVal = castToByte(value);\r\n+        if (byteVal == null) {\r\n+            return 0;\r\n+        }\r\n+\r\n+        return byteVal.byteValue();\r\n+    }\r\n+\r\n+    public Short getShort(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToShort(value);\r\n+    }\r\n+\r\n+    public short getShortValue(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        Short shortVal = castToShort(value);\r\n+        if (shortVal == null) {\r\n+            return 0;\r\n+        }\r\n+\r\n+        return shortVal.shortValue();\r\n+    }\r\n+\r\n+    public Integer getInteger(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToInt(value);\r\n+    }\r\n+\r\n+    public int getIntValue(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        Integer intVal = castToInt(value);\r\n+        if (intVal == null) {\r\n+            return 0;\r\n+        }\r\n+\r\n+        return intVal.intValue();\r\n+    }\r\n+\r\n+    public Long getLong(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToLong(value);\r\n+    }\r\n+\r\n+    public long getLongValue(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        Long longVal = castToLong(value);\r\n+        if (longVal == null) {\r\n+            return 0L;\r\n+        }\r\n+\r\n+        return longVal.longValue();\r\n+    }\r\n+\r\n+    public Float getFloat(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToFloat(value);\r\n+    }\r\n+\r\n+    public float getFloatValue(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        Float floatValue = castToFloat(value);\r\n+        if (floatValue == null) {\r\n+            return 0F;\r\n+        }\r\n+\r\n+        return floatValue.floatValue();\r\n+    }\r\n+\r\n+    public Double getDouble(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToDouble(value);\r\n+    }\r\n+\r\n+    public double getDoubleValue(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        Double doubleValue = castToDouble(value);\r\n+        if (doubleValue == null) {\r\n+            return 0D;\r\n+        }\r\n+\r\n+        return doubleValue.doubleValue();\r\n+    }\r\n+\r\n+    public BigDecimal getBigDecimal(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToBigDecimal(value);\r\n+    }\r\n+\r\n+    public BigInteger getBigInteger(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToBigInteger(value);\r\n+    }\r\n+\r\n+    public String getString(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        if (value == null) {\r\n+            return null;\r\n+        }\r\n+\r\n+        return value.toString();\r\n+    }\r\n+\r\n+    public Date getDate(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToDate(value);\r\n+    }\r\n+\r\n+    public java.sql.Date getSqlDate(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToSqlDate(value);\r\n+    }\r\n+\r\n+    public java.sql.Timestamp getTimestamp(String key) {\r\n+        Object value = get(key);\r\n+\r\n+        return castToTimestamp(value);\r\n+    }\r\n+\r\n+    public Object put(String key, Object value) {\r\n+        return map.put(key, value);\r\n+    }\r\n+\r\n+    public JSONObject fluentPut(String key, Object value) {\r\n+        map.put(key, value);\r\n+        return this;\r\n+    }\r\n+\r\n+    public void putAll(Map<? extends String, ?> m) {\r\n+        map.putAll(m);\r\n+    }\r\n+\r\n+    public JSONObject fluentPutAll(Map<? extends String, ?> m) {\r\n+        map.putAll(m);\r\n+        return this;\r\n+    }\r\n+\r\n+    public void clear() {\r\n+        map.clear();\r\n+    }\r\n+\r\n+    public JSONObject fluentClear() {\r\n+        map.clear();\r\n+        return this;\r\n+    }\r\n+\r\n+    public Object remove(Object key) {\r\n+        return map.remove(key);\r\n+    }\r\n+\r\n+    public JSONObject fluentRemove(Object key) {\r\n+        map.remove(key);\r\n+        return this;\r\n+    }\r\n+\r\n+    public Set<String> keySet() {\r\n+        return map.keySet();\r\n+    }\r\n+\r\n+    public Collection<Object> values() {\r\n+        return map.values();\r\n+    }\r\n+\r\n+    public Set<Map.Entry<String, Object>> entrySet() {\r\n+        return map.entrySet();\r\n+    }\r\n+\r\n+    @Override\r\n+    public Object clone() {\r\n+        return new JSONObject(map instanceof LinkedHashMap //\r\n+                ? new LinkedHashMap<String, Object>(map) //\r\n+                : new HashMap<String, Object>(map)\r\n+        );\r\n+    }\r\n+\r\n+    public boolean equals(Object obj) {\r\n+        return this.map.equals(obj);\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return this.map.hashCode();\r\n+    }\r\n+\r\n+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n+        Class<?>[] parameterTypes = method.getParameterTypes();\r\n+        if (parameterTypes.length == 1) {\r\n+            if (method.getName().equals(\"equals\")) {\r\n+                return this.equals(args[0]);\r\n+            }\r\n+\r\n+            Class<?> returnType = method.getReturnType();\r\n+            if (returnType != void.class) {\r\n+                throw new JSONException(\"illegal setter\");\r\n+            }\r\n+\r\n+            String name = null;\r\n+            JSONField annotation = TypeUtils.getAnnotation(method, JSONField.class);\r\n+            if (annotation != null) {\r\n+                if (annotation.name().length() != 0) {\r\n+                    name = annotation.name();\r\n+                }\r\n+            }\r\n+\r\n+            if (name == null) {\r\n+                name = method.getName();\r\n+\r\n+                if (!name.startsWith(\"set\")) {\r\n+                    throw new JSONException(\"illegal setter\");\r\n+                }\r\n+\r\n+                name = name.substring(3);\r\n+                if (name.length() == 0) {\r\n+                    throw new JSONException(\"illegal setter\");\r\n+                }\r\n+                name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\r\n+            }\r\n+\r\n+            map.put(name, args[0]);\r\n+            return null;\r\n+        }\r\n+\r\n+        if (parameterTypes.length == 0) {\r\n+            Class<?> returnType = method.getReturnType();\r\n+            if (returnType == void.class) {\r\n+                throw new JSONException(\"illegal getter\");\r\n+            }\r\n+\r\n+            String name = null;\r\n+            JSONField annotation = TypeUtils.getAnnotation(method, JSONField.class);\r\n+            if (annotation != null) {\r\n+                if (annotation.name().length() != 0) {\r\n+                    name = annotation.name();\r\n+                }\r\n+            }\r\n+\r\n+            if (name == null) {\r\n+                name = method.getName();\r\n+                if (name.startsWith(\"get\")) {\r\n+                    name = name.substring(3);\r\n+                    if (name.length() == 0) {\r\n+                        throw new JSONException(\"illegal getter\");\r\n+                    }\r\n+                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\r\n+                } else if (name.startsWith(\"is\")) {\r\n+                    name = name.substring(2);\r\n+                    if (name.length() == 0) {\r\n+                        throw new JSONException(\"illegal getter\");\r\n+                    }\r\n+                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\r\n+                } else if (name.startsWith(\"hashCode\")) {\r\n+                    return this.hashCode();\r\n+                } else if (name.startsWith(\"toString\")) {\r\n+                    return this.toString();\r\n+                } else {\r\n+                    throw new JSONException(\"illegal getter\");\r\n+                }\r\n+            }\r\n+\r\n+            Object value = map.get(name);\r\n+            return TypeUtils.cast(value, method.getGenericReturnType(), ParserConfig.getGlobalInstance());\r\n+        }\r\n+\r\n+        throw new UnsupportedOperationException(method.toGenericString());\r\n+    }\r\n+\r\n+    public Map<String, Object> getInnerMap() {\r\n+        return this.map;\r\n+    }\r\n+\r\n+\r\n+\r\n+    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {\r\n+        SecureObjectInputStream.ensureFields();\r\n+        if (SecureObjectInputStream.fields != null && !SecureObjectInputStream.fields_error) {\r\n+            ObjectInputStream secIn = new SecureObjectInputStream(in);\r\n+            try {\r\n+                secIn.defaultReadObject();\r\n+                return;\r\n+            } catch (java.io.NotActiveException e) {\r\n+                // skip\r\n+            }\r\n+        }\r\n+\r\n+        in.defaultReadObject();\r\n+        for (Entry entry : map.entrySet()) {\r\n+            final Object key = entry.getKey();\r\n+            if (key != null) {\r\n+                ParserConfig.global.checkAutoType(key.getClass());\r\n+            }\r\n+\r\n+            final Object value = entry.getValue();\r\n+            if (value != null) {\r\n+                ParserConfig.global.checkAutoType(value.getClass());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    static class SecureObjectInputStream extends ObjectInputStream {\r\n+        static Field[] fields;\r\n+        static volatile boolean fields_error;\r\n+\r\n+        static void ensureFields() {\r\n+            if (fields == null && !fields_error) {\r\n+                try {\r\n+                    final Field[] declaredFields = ObjectInputStream.class.getDeclaredFields();\r\n+                    String[] fieldnames = new String[]{\"bin\", \"passHandle\", \"handles\", \"curContext\"};\r\n+                    Field[] array = new Field[fieldnames.length];\r\n+                    for (int i = 0; i < fieldnames.length; i++) {\r\n+                        Field field = TypeUtils\r\n+                                .getField(ObjectInputStream.class\r\n+                                        , fieldnames[i]\r\n+                                        , declaredFields\r\n+                                );\r\n+                        field.setAccessible(true);\r\n+                        array[i] = field;\r\n+                    }\r\n+                    fields = array;\r\n+                } catch (Throwable error) {\r\n+                    fields_error = true;\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        public SecureObjectInputStream(ObjectInputStream in) throws IOException {\r\n+            super(in);\r\n+            try {\r\n+                for (int i = 0; i < fields.length; i++) {\r\n+                    final Field field = fields[i];\r\n+                    final Object value = field.get(in);\r\n+                    field.set(this, value);\r\n+                }\r\n+            } catch (IllegalAccessException e) {\r\n+                fields_error = true;\r\n+            }\r\n+        }\r\n+\r\n+        protected Class<?> resolveClass(ObjectStreamClass desc)\r\n+                throws IOException, ClassNotFoundException {\r\n+            String name = desc.getName();\r\n+            if (name.length() > 2) {\r\n+                int index = name.lastIndexOf('[');\r\n+                if (index != -1) {\r\n+                    name = name.substring(index + 1);\r\n+                }\r\n+                if (name.length() > 2 && name.charAt(0) == 'L' && name.charAt(name.length() - 1) == ';') {\r\n+                    name = name.substring(1, name.length() - 1);\r\n+                }\r\n+\r\n+                if (TypeUtils.getClassFromMapping(name) == null) {\r\n+                    ParserConfig.global.checkAutoType(name, null, Feature.SupportAutoType.mask);\r\n+                }\r\n+            }\r\n+            return super.resolveClass(desc);\r\n+        }\r\n+\r\n+        protected Class<?> resolveProxyClass(String[] interfaces)\r\n+                throws IOException, ClassNotFoundException {\r\n+            for (String interfacename : interfaces) {\r\n+                //\r\n+                if (TypeUtils.getClassFromMapping(interfacename) == null) {\r\n+                    ParserConfig.global.checkAutoType(interfacename, null);\r\n+                }\r\n+            }\r\n+            return super.resolveProxyClass(interfaces);\r\n+        }\r\n+\r\n+        //Hack:\r\n+        protected void readStreamHeader() throws IOException, StreamCorruptedException {\r\n+\r\n+        }\r\n+    }\r\n+\r\n+    public <T> T toJavaObject(Class<T> clazz) {\r\n+        if (clazz == Map.class || clazz == JSONObject.class || clazz == JSON.class) {\r\n+            return (T) this;\r\n+        }\r\n+\r\n+        if (clazz == Object.class && !containsKey(JSON.DEFAULT_TYPE_KEY)) {\r\n+            return (T) this;\r\n+        }\r\n+\r\n+        return TypeUtils.castToJavaBean(this, clazz, ParserConfig.getGlobalInstance());\r\n+    }\r\n+\r\n+    public <T> T toJavaObject(Class<T> clazz, ParserConfig config, int features) {\r\n+        if (clazz == Map.class) {\r\n+            return (T) this;\r\n+        }\r\n+\r\n+        if (clazz == Object.class && !containsKey(JSON.DEFAULT_TYPE_KEY)) {\r\n+            return (T) this;\r\n+        }\r\n+\r\n+        return TypeUtils.castToJavaBean(this, clazz, config);\r\n+    }\r\n+}\r"},{"sha":"b4527c4c9f2803407c764de1a50cf715c2d28286","filename":"src/main/java/com/alibaba/fastjson/JSONPObject.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONPObject.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONPObject.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONPObject.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,70 @@\n+package com.alibaba.fastjson;\n+\n+import com.alibaba.fastjson.serializer.JSONSerializable;\n+import com.alibaba.fastjson.serializer.JSONSerializer;\n+import com.alibaba.fastjson.serializer.SerializeWriter;\n+import com.alibaba.fastjson.serializer.SerializerFeature;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class JSONPObject implements JSONSerializable {\n+    public static String SECURITY_PREFIX = \"/**/\";\n+    private String             function;\n+\n+    private final List<Object> parameters = new ArrayList<Object>();\n+\n+    public JSONPObject() {\n+\n+    }\n+\n+    public JSONPObject(String function) {\n+        this.function = function;\n+    }\n+\n+    public String getFunction() {\n+        return function;\n+    }\n+\n+    public void setFunction(String function) {\n+        this.function = function;\n+    }\n+\n+    public List<Object> getParameters() {\n+        return parameters;\n+    }\n+\n+    public void addParameter(Object parameter) {\n+        this.parameters.add(parameter);\n+    }\n+\n+    public String toJSONString() {\n+        return toString();\n+    }\n+\n+    public void write(JSONSerializer serializer, Object fieldName, Type fieldType, int features) throws IOException {\n+        SerializeWriter writer = serializer.out;\n+\n+        if ((features & SerializerFeature.BrowserSecure.mask) != 0\n+                || (writer.isEnabled(SerializerFeature.BrowserSecure.mask)))\n+        {\n+            writer.write(SECURITY_PREFIX);\n+        }\n+\n+        writer.write(function);\n+        writer.write('(');\n+        for (int i = 0; i < parameters.size(); ++i) {\n+            if (i != 0) {\n+                writer.write(',');\n+            }\n+            serializer.write(parameters.get(i));\n+        }\n+        writer.write(')');\n+    }\n+\n+    public String toString() {\n+        return JSON.toJSONString(this);\n+    }\n+}"},{"sha":"05db0db6c0473a11f6d06d2b3c53beb6925e50a1","filename":"src/main/java/com/alibaba/fastjson/JSONPatch.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONPatch.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONPatch.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONPatch.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,91 @@\n+package com.alibaba.fastjson;\n+\n+import com.alibaba.fastjson.annotation.JSONField;\n+import com.alibaba.fastjson.annotation.JSONType;\n+import com.alibaba.fastjson.parser.Feature;\n+import com.alibaba.fastjson.parser.JSONScanner;\n+\n+public class JSONPatch {\n+    public static String apply(String original, String patch) {\n+        Object object\n+                = apply(\n+                        JSON.parse(original, Feature.OrderedField), patch);\n+        return JSON.toJSONString(object);\n+    }\n+\n+    public static Object apply(Object object, String patch) {\n+        Operation[] operations;\n+        if (isObject(patch)) {\n+            operations = new Operation[] {\n+                    JSON.parseObject(patch, Operation.class)};\n+        } else {\n+            operations = JSON.parseObject(patch, Operation[].class);\n+        }\n+\n+        for (Operation op : operations) {\n+            JSONPath path = JSONPath.compile(op.path);\n+            switch (op.type) {\n+                case add:\n+                    path.patchAdd(object, op.value, false);\n+                    break;\n+                case replace:\n+                    path.patchAdd(object, op.value, true);\n+                    break;\n+                case remove:\n+                    path.remove(object);\n+                    break;\n+                case copy:\n+                case move:\n+                    JSONPath from = JSONPath.compile(op.from);\n+                    Object fromValue = from.eval(object);\n+                    if (op.type == OperationType.move) {\n+                        boolean success = from.remove(object);\n+                        if (!success) {\n+                            throw new JSONException(\"json patch move error : \" + op.from + \" -> \" + op.path);\n+                        }\n+                    }\n+                    path.set(object, fromValue);\n+                    break;\n+                case test:\n+                    Object result = path.eval(object);\n+                    if (result == null) {\n+                        return op.value == null;\n+                    }\n+                    return result.equals(op.value);\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        return object;\n+    }\n+\n+    private static boolean isObject(String patch) {\n+        if (patch == null) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < patch.length(); ++i) {\n+            char ch = patch.charAt(i);\n+            if (JSONScanner.isWhitespace(ch)) {\n+                continue;\n+            }\n+            return ch == '{';\n+        }\n+\n+        return false;\n+    }\n+\n+    @JSONType(orders = {\"op\", \"from\", \"path\", \"value\"})\n+    public static class Operation {\n+        @JSONField(name = \"op\")\n+        public OperationType type;\n+        public String from;\n+        public String path;\n+        public Object value;\n+    }\n+\n+    public enum OperationType {\n+        add, remove, replace, move, copy, test\n+    }\n+}"},{"sha":"ed6b1065a5642723f49fca5dd8ab4e19c6f9f377","filename":"src/main/java/com/alibaba/fastjson/JSONPath.java","status":"added","additions":4362,"deletions":0,"changes":4362,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONPath.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONPath.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONPath.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d"},{"sha":"a514cf4cb383bcac2130b622d864933ff1090160","filename":"src/main/java/com/alibaba/fastjson/JSONPathException.java","status":"added","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONPathException.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONPathException.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONPathException.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,13 @@\n+package com.alibaba.fastjson;\n+\n+@SuppressWarnings(\"serial\")\n+public class JSONPathException extends JSONException {\n+\n+    public JSONPathException(String message){\n+        super(message);\n+    }\n+    \n+    public JSONPathException(String message, Throwable cause){\n+        super(message, cause);\n+    }\n+}"},{"sha":"7c226a2c4be85c5e4dcf47a3cccb59b04e9411f3","filename":"src/main/java/com/alibaba/fastjson/JSONReader.java","status":"added","additions":345,"deletions":0,"changes":345,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONReader.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONReader.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONReader.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,345 @@\n+package com.alibaba.fastjson;\n+\n+import static com.alibaba.fastjson.JSONStreamContext.ArrayValue;\n+import static com.alibaba.fastjson.JSONStreamContext.PropertyKey;\n+import static com.alibaba.fastjson.JSONStreamContext.PropertyValue;\n+import static com.alibaba.fastjson.JSONStreamContext.StartArray;\n+import static com.alibaba.fastjson.JSONStreamContext.StartObject;\n+\n+import java.io.Closeable;\n+import java.io.Reader;\n+import java.lang.reflect.Type;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+import com.alibaba.fastjson.parser.DefaultJSONParser;\n+import com.alibaba.fastjson.parser.Feature;\n+import com.alibaba.fastjson.parser.JSONLexer;\n+import com.alibaba.fastjson.parser.JSONReaderScanner;\n+import com.alibaba.fastjson.parser.JSONToken;\n+import com.alibaba.fastjson.util.TypeUtils;\n+\n+public class JSONReader implements Closeable {\n+\n+    private final DefaultJSONParser parser;\n+    private JSONStreamContext       context;\n+    private transient JSONStreamContext lastContext;\n+\n+    public JSONReader(Reader reader){\n+        this(reader, new Feature[0]);\n+    }\n+    \n+    public JSONReader(Reader reader, Feature... features){\n+        this(new JSONReaderScanner(reader));\n+        for (Feature feature : features) {\n+            this.config(feature, true);\n+        }\n+    }\n+\n+    public JSONReader(JSONLexer lexer){\n+        this(new DefaultJSONParser(lexer));\n+    }\n+\n+    public JSONReader(DefaultJSONParser parser){\n+        this.parser = parser;\n+    }\n+    \n+    public void setTimzeZone(TimeZone timezone) {\n+        this.parser.lexer.setTimeZone(timezone);\n+    }\n+    \n+    public void setLocale(Locale locale) {\n+        this.parser.lexer.setLocale(locale);\n+    }\n+\n+    public void config(Feature feature, boolean state) {\n+        this.parser.config(feature, state);\n+    }\n+    \n+    public Locale getLocal() {\n+        return this.parser.lexer.getLocale();\n+    }\n+    \n+    public TimeZone getTimzeZone() {\n+        return this.parser.lexer.getTimeZone();\n+    }\n+\n+    public void startObject() {\n+        if (context == null) {\n+            context = new JSONStreamContext(null, JSONStreamContext.StartObject);\n+        } else {\n+            startStructure();\n+            if (lastContext != null\n+                    && lastContext.parent == context) {\n+                context = lastContext;\n+                if (context.state != JSONStreamContext.StartObject) {\n+                    context.state = JSONStreamContext.StartObject;\n+                }\n+            } else {\n+                context = new JSONStreamContext(context, JSONStreamContext.StartObject);\n+            }\n+        }\n+\n+        this.parser.accept(JSONToken.LBRACE, JSONToken.IDENTIFIER);\n+    }\n+\n+    public void endObject() {\n+        this.parser.accept(JSONToken.RBRACE);\n+        endStructure();\n+    }\n+\n+    public void startArray() {\n+        if (context == null) {\n+            context = new JSONStreamContext(null, StartArray);\n+        } else {\n+            startStructure();\n+\n+            context = new JSONStreamContext(context, StartArray);\n+        }\n+        this.parser.accept(JSONToken.LBRACKET);\n+    }\n+\n+    public void endArray() {\n+        this.parser.accept(JSONToken.RBRACKET);\n+        endStructure();\n+    }\n+\n+    private void startStructure() {\n+        final int state = context.state;\n+        switch (state) {\n+            case PropertyKey:\n+                parser.accept(JSONToken.COLON);\n+                break;\n+            case PropertyValue:\n+            case ArrayValue:\n+                parser.accept(JSONToken.COMMA);\n+                break;\n+            case StartArray:\n+            case StartObject:\n+                break;\n+            default:\n+                throw new JSONException(\"illegal state : \" + context.state);\n+        }\n+    }\n+\n+    private void endStructure() {\n+        lastContext = context;\n+        context = context.parent;\n+\n+        if (context == null) {\n+            return;\n+        }\n+        \n+        final int state = context.state;\n+        int newState = -1;\n+        switch (state) {\n+            case PropertyKey:\n+                newState = PropertyValue;\n+                break;\n+            case StartArray:\n+                newState = ArrayValue;\n+                break;\n+            case PropertyValue:\n+            case StartObject:\n+                newState = PropertyKey;\n+                break;\n+            default:\n+                break;\n+        }\n+        if (newState != -1) {\n+            context.state = newState;\n+        }\n+    }\n+\n+    public boolean hasNext() {\n+        if (context == null) {\n+            throw new JSONException(\"context is null\");\n+        }\n+\n+        final int token = parser.lexer.token();\n+        final int state = context.state;\n+        switch (state) {\n+            case StartArray:\n+            case ArrayValue:\n+                return token != JSONToken.RBRACKET;\n+            case StartObject:\n+            case PropertyValue:\n+                return token != JSONToken.RBRACE;\n+            default:\n+                throw new JSONException(\"illegal state : \" + state);\n+        }\n+    }\n+\n+    public int peek() {\n+        return parser.lexer.token();\n+    }\n+\n+    public void close() {\n+        parser.close();\n+    }\n+\n+    public Integer readInteger() {\n+        Object object;\n+        if (context == null) {\n+            object = parser.parse();\n+        } else {\n+            readBefore();\n+            object = parser.parse();\n+            readAfter();\n+        }\n+\n+        return TypeUtils.castToInt(object);\n+    }\n+\n+    public Long readLong() {\n+        Object object;\n+        if (context == null) {\n+            object = parser.parse();\n+        } else {\n+            readBefore();\n+            object = parser.parse();\n+            readAfter();\n+        }\n+\n+        return TypeUtils.castToLong(object);\n+    }\n+\n+    public String readString() {\n+        Object object;\n+        if (context == null) {\n+            object = parser.parse();\n+        } else {\n+            readBefore();\n+            JSONLexer lexer = parser.lexer;\n+            if (context.state == JSONStreamContext.StartObject && lexer.token() == JSONToken.IDENTIFIER) {\n+                object = lexer.stringVal();\n+                lexer.nextToken();\n+            } else {\n+                object = parser.parse();\n+            }\n+            readAfter();\n+        }\n+\n+        return TypeUtils.castToString(object);\n+    }\n+    \n+    public <T> T readObject(TypeReference<T> typeRef) {\n+        return readObject(typeRef.getType());\n+    }\n+\n+    public <T> T readObject(Type type) {\n+        if (context == null) {\n+            return parser.parseObject(type);\n+        }\n+\n+        readBefore();\n+        T object = parser.parseObject(type);\n+        readAfter();\n+        return object;\n+    }\n+\n+    public <T> T readObject(Class<T> type) {\n+        if (context == null) {\n+            return parser.parseObject(type);\n+        }\n+\n+        readBefore();\n+        T object = parser.parseObject(type);\n+        readAfter();\n+        return object;\n+    }\n+\n+    public void readObject(Object object) {\n+        if (context == null) {\n+            parser.parseObject(object);\n+            return;\n+        }\n+\n+        readBefore();\n+        parser.parseObject(object);\n+        readAfter();\n+    }\n+\n+    public Object readObject() {\n+        if (context == null) {\n+            return parser.parse();\n+        }\n+\n+        readBefore();\n+        Object object;\n+        switch (context.state) {\n+            case StartObject:\n+            case PropertyValue:\n+                object = parser.parseKey();\n+                break;\n+            default:\n+                object = parser.parse();\n+                break;\n+        }\n+\n+        readAfter();\n+        return object;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public Object readObject(Map object) {\n+        if (context == null) {\n+            return parser.parseObject(object);\n+        }\n+\n+        readBefore();\n+        Object value = parser.parseObject(object);\n+        readAfter();\n+        return value;\n+    }\n+\n+    private void readBefore() {\n+        int state = context.state;\n+        // before\n+        switch (state) {\n+            case PropertyKey:\n+                parser.accept(JSONToken.COLON);\n+                break;\n+            case PropertyValue:\n+                parser.accept(JSONToken.COMMA, JSONToken.IDENTIFIER);\n+                break;\n+            case ArrayValue:\n+                parser.accept(JSONToken.COMMA);\n+                break;\n+            case StartObject:\n+                break;\n+            case StartArray:\n+                break;\n+            default:\n+                throw new JSONException(\"illegal state : \" + state);\n+        }\n+    }\n+\n+    private void readAfter() {\n+        int state = context.state;\n+        int newStat = -1;\n+        switch (state) {\n+            case StartObject:\n+                newStat = PropertyKey;\n+                break;\n+            case PropertyKey:\n+                newStat = PropertyValue;\n+                break;\n+            case PropertyValue:\n+                newStat = PropertyKey;\n+                break;\n+            case ArrayValue:\n+                break;\n+            case StartArray:\n+                newStat = ArrayValue;\n+                break;\n+            default:\n+                throw new JSONException(\"illegal state : \" + state);\n+        }\n+        if (newStat != -1) {\n+            context.state = newStat;\n+        }\n+    }\n+\n+}"},{"sha":"844579dfcbb6fe57d547b6511e4e198d5119ecb1","filename":"src/main/java/com/alibaba/fastjson/JSONStreamAware.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONStreamAware.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONStreamAware.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONStreamAware.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,31 @@\n+/*\r\n+ * Copyright 1999-2017 Alibaba Group.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *      http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package com.alibaba.fastjson;\r\n+\r\n+import java.io.IOException;\r\n+\r\n+/**\r\n+ * Beans that support customized output of JSON text to a writer shall implement this interface.\r\n+ * \r\n+ * @author wenshao[szujobs@hotmail.com]\r\n+ */\r\n+public interface JSONStreamAware {\r\n+\r\n+    /**\r\n+     * write JSON string to out.\r\n+     */\r\n+    void writeJSONString(Appendable out) throws IOException;\r\n+}\r"},{"sha":"a0309a1376f7e770bffbfd3dae3a93dd47aade52","filename":"src/main/java/com/alibaba/fastjson/JSONStreamContext.java","status":"added","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONStreamContext.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONStreamContext.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONStreamContext.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,19 @@\n+package com.alibaba.fastjson;\n+\n+class JSONStreamContext {\n+\n+    final static int                  StartObject   = 1001;\n+    final static int                  PropertyKey   = 1002;\n+    final static int                  PropertyValue = 1003;\n+    final static int                  StartArray    = 1004;\n+    final static int                  ArrayValue    = 1005;\n+\n+    protected final JSONStreamContext parent;\n+\n+    protected int                     state;\n+\n+    public JSONStreamContext(JSONStreamContext parent, int state){\n+        this.parent = parent;\n+        this.state = state;\n+    }\n+}"},{"sha":"1399648fe7800d18bde10591a3f14dff1d12bcbc","filename":"src/main/java/com/alibaba/fastjson/JSONValidator.java","status":"added","additions":613,"deletions":0,"changes":613,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONValidator.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONValidator.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONValidator.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,613 @@\n+package com.alibaba.fastjson;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+\n+public abstract class JSONValidator implements Cloneable, Closeable {\n+    public enum Type {\n+        Object, Array, Value\n+    }\n+\n+    protected boolean eof;\n+    protected int pos = -1;\n+    protected char ch;\n+    protected Type type;\n+    private Boolean valiateResult;\n+\n+    protected int count = 0;\n+    protected boolean supportMultiValue = false;\n+\n+    public static JSONValidator fromUtf8(byte[] jsonBytes) {\n+        return new UTF8Validator(jsonBytes);\n+    }\n+\n+    public static JSONValidator fromUtf8(InputStream is) {\n+        return new UTF8InputStreamValidator(is);\n+    }\n+\n+    public static JSONValidator from(String jsonStr) {\n+        return new UTF16Validator(jsonStr);\n+    }\n+\n+    public static JSONValidator from(Reader r) {\n+        return new ReaderValidator(r);\n+    }\n+\n+    public boolean isSupportMultiValue() {\n+        return supportMultiValue;\n+    }\n+\n+    public JSONValidator setSupportMultiValue(boolean supportMultiValue) {\n+        this.supportMultiValue = supportMultiValue;\n+        return this;\n+    }\n+\n+    public Type getType() {\n+        if (type == null) {\n+            validate();\n+        }\n+\n+        return type;\n+    }\n+\n+    abstract void next();\n+\n+    public boolean validate() {\n+        if (valiateResult != null) {\n+            return valiateResult;\n+        }\n+\n+        for (;;) {\n+            if (!any()) {\n+                valiateResult = false;\n+                return false;\n+            }\n+            skipWhiteSpace();\n+\n+            count++;\n+            if (eof) {\n+                valiateResult = true;\n+                return true;\n+            }\n+\n+            if (supportMultiValue) {\n+                skipWhiteSpace();\n+                if (eof) {\n+                    break;\n+                }\n+                continue;\n+            } else {\n+                valiateResult = false;\n+                return false;\n+            }\n+        }\n+\n+        valiateResult = true;\n+        return true;\n+    }\n+\n+    public void close() throws IOException {\n+\n+    }\n+\n+    private boolean any() {\n+        switch (ch) {\n+            case '{':\n+                next();\n+\n+                while (isWhiteSpace(ch)) {\n+                    next();\n+                }\n+\n+                if (ch == '}') {\n+                    next();\n+                    type = Type.Object;\n+                    return true;\n+                }\n+\n+                for (;;) {\n+                    if (ch == '\"') {\n+                        fieldName();\n+                    } else {\n+                        return false;\n+                    }\n+\n+                    skipWhiteSpace();\n+                    if (ch == ':') {\n+                        next();\n+                    } else {\n+                        return false;\n+                    }\n+                    skipWhiteSpace();\n+\n+                    if (!any()) {\n+                        return false;\n+                    }\n+\n+                    skipWhiteSpace();\n+                    if (ch == ',') {\n+                        next();\n+                        skipWhiteSpace();\n+                        continue;\n+                    } else if (ch == '}') {\n+                        next();\n+                        type = Type.Object;\n+                        return true;\n+                    }\n+                }\n+            case '[':\n+                next();\n+                skipWhiteSpace();\n+\n+                if (ch == ']') {\n+                    next();\n+                    type = Type.Array;\n+                    return true;\n+                }\n+\n+                for (;;) {\n+                    if (!any()) {\n+                        return false;\n+                    }\n+\n+                    skipWhiteSpace();\n+                    if (ch == ',') {\n+                        next();\n+                        skipWhiteSpace();\n+                    } else if (ch == ']') {\n+                        next();\n+                        type = Type.Array;\n+                        return true;\n+                    }\n+                    else {\n+                        return false;\n+                    }\n+                }\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+            case '4':\n+            case '5':\n+            case '6':\n+            case '7':\n+            case '8':\n+            case '9':\n+            case '+':\n+            case '-':\n+                if (ch == '-' || ch == '+') {\n+                    next();\n+                    skipWhiteSpace();\n+                    if (ch < '0' || ch > '9') {\n+                        return false;\n+                    }\n+                }\n+\n+                do {\n+                    next();\n+                } while (ch >= '0' && ch <= '9');\n+\n+                if (ch == '.') {\n+                    next();\n+                    // bug fix: 0.e7 should not pass the test\n+                    if (ch < '0' || ch > '9') {\n+                        return false;\n+                    }\n+                    while (ch >= '0' && ch <= '9') {\n+                        next();\n+                    }\n+                }\n+\n+                if (ch == 'e' || ch == 'E') {\n+                    next();\n+                    if (ch == '-' || ch == '+') {\n+                        next();\n+                    }\n+\n+                    if (ch >= '0' && ch <= '9') {\n+                        next();\n+                    }\n+                    else {\n+                        return false;\n+                    }\n+\n+                    while (ch >= '0' && ch <= '9') {\n+                        next();\n+                    }\n+                }\n+\n+                type = Type.Value;\n+                break;\n+            case '\"':\n+                next();\n+                for (;;) {\n+                    if (eof) {\n+                        return false;\n+                    }\n+\n+                    if (ch == '\\\\') {\n+                        next();\n+                        if (ch == 'u') {\n+                            next();\n+\n+                            next();\n+                            next();\n+                            next();\n+                            next();\n+                        } else {\n+                            next();\n+                        }\n+                    } else if (ch == '\"') {\n+                        next();\n+                        type = Type.Value;\n+                        return true;\n+                    } else {\n+                        next();\n+                    }\n+                }\n+            case 't':\n+                next();\n+\n+                if (ch != 'r') {\n+                    return false;\n+                }\n+                next();\n+\n+                if (ch != 'u') {\n+                    return false;\n+                }\n+                next();\n+\n+                if (ch != 'e') {\n+                    return false;\n+                }\n+                next();\n+\n+                if (isWhiteSpace(ch) || ch == ',' || ch == ']' || ch == '}' || ch == '\\0') {\n+                    type = Type.Value;\n+                    return true;\n+                }\n+                return false;\n+            case 'f':\n+                next();\n+\n+                if (ch != 'a') {\n+                    return false;\n+                }\n+                next();\n+\n+                if (ch != 'l') {\n+                    return false;\n+                }\n+                next();\n+\n+                if (ch != 's') {\n+                    return false;\n+                }\n+                next();\n+\n+                if (ch != 'e') {\n+                    return false;\n+                }\n+                next();\n+\n+                if (isWhiteSpace(ch) || ch == ',' || ch == ']' || ch == '}' || ch == '\\0') {\n+                    type = Type.Value;\n+                    return true;\n+                }\n+                return false;\n+            case 'n':\n+                next();\n+\n+                if (ch != 'u') {\n+                    return false;\n+                }\n+                next();\n+\n+                if (ch != 'l') {\n+                    return false;\n+                }\n+                next();\n+\n+                if (ch != 'l') {\n+                    return false;\n+                }\n+                next();\n+\n+                if (isWhiteSpace(ch) || ch == ',' || ch == ']' || ch == '}' || ch == '\\0') {\n+                    type = Type.Value;\n+                    return true;\n+                }\n+                return false;\n+            default:\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    protected void fieldName()\n+    {\n+        next();\n+        for (; ; ) {\n+            if (ch == '\\\\') {\n+                next();\n+\n+                if (ch == 'u') {\n+                    next();\n+\n+                    next();\n+                    next();\n+                    next();\n+                    next();\n+                } else {\n+                    next();\n+                }\n+            }\n+            else if (ch == '\"') {\n+                next();\n+                break;\n+            }\n+            else {\n+                next();\n+            }\n+        }\n+    }\n+\n+    protected boolean string()\n+    {\n+        next();\n+        for (; !eof; ) {\n+            if (ch == '\\\\') {\n+                next();\n+\n+                if (ch == 'u') {\n+                    next();\n+\n+                    next();\n+                    next();\n+                    next();\n+                    next();\n+                } else {\n+                    next();\n+                }\n+            }\n+            else if (ch == '\"') {\n+                next();\n+                return true;\n+            }\n+            else {\n+                next();\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    void skipWhiteSpace() {\n+        while (isWhiteSpace(ch)) {\n+            next();\n+        }\n+    }\n+\n+    static final boolean isWhiteSpace(char ch) {\n+        return ch == ' '\n+                || ch == '\\t'\n+                || ch == '\\r'\n+                || ch == '\\n'\n+                || ch == '\\f'\n+                || ch == '\\b'\n+                ;\n+    }\n+\n+    static class UTF8Validator extends JSONValidator {\n+        private final byte[] bytes;\n+\n+        public UTF8Validator(byte[] bytes) {\n+            this.bytes = bytes;\n+            next();\n+            skipWhiteSpace();\n+        }\n+\n+        void next() {\n+            ++pos;\n+\n+            if (pos >= bytes.length) {\n+                ch = '\\0';\n+                eof = true;\n+            } else {\n+                ch = (char) bytes[pos];\n+            }\n+        }\n+    }\n+\n+    static class UTF8InputStreamValidator extends JSONValidator {\n+        private final static ThreadLocal<byte[]> bufLocal = new ThreadLocal<byte[]>();\n+\n+        private final InputStream is;\n+        private byte[] buf;\n+        private int end = -1;\n+        private int readCount = 0;\n+\n+        public UTF8InputStreamValidator(InputStream is) {\n+            this.is = is;\n+            buf = bufLocal.get();\n+            if (buf != null) {\n+                bufLocal.set(null);\n+            } else {\n+                buf = new byte[1024 * 8];\n+            }\n+\n+            next();\n+            skipWhiteSpace();\n+        }\n+\n+        void next() {\n+            if (pos < end) {\n+                ch = (char) buf[++pos];\n+            } else {\n+                if (!eof) {\n+                    int len;\n+                    try {\n+                        len = is.read(buf, 0, buf.length);\n+                        readCount++;\n+                    } catch (IOException ex) {\n+                        throw new JSONException(\"read error\");\n+                    }\n+\n+                    if (len > 0) {\n+                        ch = (char) buf[0];\n+                        pos = 0;\n+                        end = len - 1;\n+                    }\n+                    else if (len == -1) {\n+                        pos = 0;\n+                        end = 0;\n+                        buf = null;\n+                        ch = '\\0';\n+                        eof = true;\n+                    } else {\n+                        pos = 0;\n+                        end = 0;\n+                        buf = null;\n+                        ch = '\\0';\n+                        eof = true;\n+                        throw new JSONException(\"read error\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        public void close() throws IOException {\n+            bufLocal.set(buf);\n+            is.close();\n+        }\n+    }\n+\n+    static class UTF16Validator extends JSONValidator {\n+        private final String str;\n+\n+        public UTF16Validator(String str) {\n+            this.str = str;\n+            next();\n+            skipWhiteSpace();\n+        }\n+\n+        void next() {\n+            ++pos;\n+\n+            if (pos >= str.length()) {\n+                ch = '\\0';\n+                eof = true;\n+            } else {\n+                ch = str.charAt(pos);\n+            }\n+        }\n+\n+        protected final void fieldName()\n+        {\n+            for (int i = pos + 1; i < str.length(); ++i) {\n+                char ch = str.charAt(i);\n+                if (ch == '\\\\') {\n+                    break;\n+                }\n+                if (ch == '\\\"') {\n+                    this.ch = str.charAt(i + 1);\n+                    pos = i + 1;\n+                    return;\n+                }\n+            }\n+\n+            next();\n+            for (; ; ) {\n+                if (ch == '\\\\') {\n+                    next();\n+\n+                    if (ch == 'u') {\n+                        next();\n+\n+                        next();\n+                        next();\n+                        next();\n+                        next();\n+                    } else {\n+                        next();\n+                    }\n+                }\n+                else if (ch == '\"') {\n+                    next();\n+                    break;\n+                }\n+                else {\n+                    next();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    static class ReaderValidator extends JSONValidator {\n+        private final static ThreadLocal<char[]> bufLocal = new ThreadLocal<char[]>();\n+\n+        final Reader r;\n+\n+        private char[] buf;\n+        private int end = -1;\n+        private int readCount = 0;\n+\n+        ReaderValidator(Reader r) {\n+            this.r = r;\n+            buf = bufLocal.get();\n+            if (buf != null) {\n+                bufLocal.set(null);\n+            } else {\n+                buf = new char[1024 * 8];\n+            }\n+\n+            next();\n+            skipWhiteSpace();\n+        }\n+\n+        void next() {\n+            if (pos < end) {\n+                ch = buf[++pos];\n+            } else {\n+                if (!eof) {\n+                    int len;\n+                    try {\n+                        len = r.read(buf, 0, buf.length);\n+                        readCount++;\n+                    } catch (IOException ex) {\n+                        throw new JSONException(\"read error\");\n+                    }\n+\n+                    if (len > 0) {\n+                        ch = buf[0];\n+                        pos = 0;\n+                        end = len - 1;\n+                    }\n+                    else if (len == -1) {\n+                        pos = 0;\n+                        end = 0;\n+                        buf = null;\n+                        ch = '\\0';\n+                        eof = true;\n+                    } else {\n+                        pos = 0;\n+                        end = 0;\n+                        buf = null;\n+                        ch = '\\0';\n+                        eof = true;\n+                        throw new JSONException(\"read error\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        public void close() throws IOException {\n+            bufLocal.set(buf);\n+            r.close();;\n+        }\n+    }\n+}"},{"sha":"d5d72f6d6d7ebe440f2b709f5946ad725fcf19b1","filename":"src/main/java/com/alibaba/fastjson/JSONWriter.java","status":"added","additions":204,"deletions":0,"changes":204,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONWriter.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/JSONWriter.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/JSONWriter.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,204 @@\n+package com.alibaba.fastjson;\n+\n+import java.io.Closeable;\n+import java.io.Flushable;\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import static com.alibaba.fastjson.JSONStreamContext.*;\n+import com.alibaba.fastjson.serializer.JSONSerializer;\n+import com.alibaba.fastjson.serializer.SerializeWriter;\n+import com.alibaba.fastjson.serializer.SerializerFeature;\n+\n+public class JSONWriter implements Closeable, Flushable {\n+\n+    private SerializeWriter   writer;\n+\n+    private JSONSerializer    serializer;\n+\n+    private JSONStreamContext context;\n+\n+    public JSONWriter(Writer out){\n+        writer = new SerializeWriter(out);\n+        serializer = new JSONSerializer(writer);\n+    }\n+\n+    public void config(SerializerFeature feature, boolean state) {\n+        this.writer.config(feature, state);\n+    }\n+\n+    public void startObject() {\n+        if (context != null) {\n+            beginStructure();\n+        }\n+        context = new JSONStreamContext(context, JSONStreamContext.StartObject);\n+        writer.write('{');\n+    }\n+\n+    public void endObject() {\n+        writer.write('}');\n+        endStructure();\n+    }\n+\n+    public void writeKey(String key) {\n+        writeObject(key);\n+    }\n+\n+    public void writeValue(Object object) {\n+        writeObject(object);\n+    }\n+\n+    public void writeObject(String object) {\n+        beforeWrite();\n+\n+        serializer.write(object);\n+\n+        afterWrite();\n+    }\n+\n+    public void writeObject(Object object) {\n+        beforeWrite();\n+        serializer.write(object);\n+        afterWrite();\n+    }\n+\n+    public void startArray() {\n+        if (context != null) {\n+            beginStructure();\n+        }\n+\n+        context = new JSONStreamContext(context, StartArray);\n+        writer.write('[');\n+    }\n+\n+    private void beginStructure() {\n+        final int state = context.state;\n+        switch (context.state) {\n+            case PropertyKey:\n+                writer.write(':');\n+                break;\n+            case ArrayValue:\n+                writer.write(',');\n+                break;\n+            case StartObject:\n+                break;\n+            case StartArray:\n+                break;\n+            default:\n+                throw new JSONException(\"illegal state : \" + state);\n+        }\n+    }\n+\n+    public void endArray() {\n+        writer.write(']');\n+        endStructure();\n+    }\n+\n+    private void endStructure() {\n+        context = context.parent;\n+\n+        if (context == null) {\n+            return;\n+        }\n+        \n+        int newState = -1;\n+        switch (context.state) {\n+            case PropertyKey:\n+                newState = PropertyValue;\n+                break;\n+            case StartArray:\n+                newState = ArrayValue;\n+                break;\n+            case ArrayValue:\n+                break;\n+            case StartObject:\n+                newState = PropertyKey;\n+                break;\n+            default:\n+                break;\n+        }\n+        if (newState != -1) {\n+            context.state = newState;\n+        }\n+    }\n+\n+    private void beforeWrite() {\n+        if (context == null) {\n+            return;\n+        }\n+        \n+        switch (context.state) {\n+            case StartObject:\n+            case StartArray:\n+                break;\n+            case PropertyKey:\n+                writer.write(':');\n+                break;\n+            case PropertyValue:\n+                writer.write(',');\n+                break;\n+            case ArrayValue:\n+                writer.write(',');\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    private void afterWrite() {\n+        if (context == null) {\n+            return;\n+        }\n+\n+        final int state = context.state;\n+        int newState = -1;\n+        switch (state) {\n+            case PropertyKey:\n+                newState = PropertyValue;\n+                break;\n+            case StartObject:\n+            case PropertyValue:\n+                newState = PropertyKey;\n+                break;\n+            case StartArray:\n+                newState = ArrayValue;\n+                break;\n+            case ArrayValue:\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        if (newState != -1) {\n+            context.state = newState;\n+        }\n+    }\n+\n+    public void flush() throws IOException {\n+        writer.flush();\n+    }\n+\n+    public void close() throws IOException {\n+        writer.close();\n+    }\n+\n+    @Deprecated\n+    public void writeStartObject() {\n+        startObject();\n+    }\n+\n+    @Deprecated\n+    public void writeEndObject() {\n+        endObject();\n+    }\n+\n+    @Deprecated\n+    public void writeStartArray() {\n+        startArray();\n+    }\n+\n+    @Deprecated\n+    public void writeEndArray() {\n+        endArray();\n+    }\n+}"},{"sha":"7d7f416f23ef2a806da5ad3349c685a24a6f3894","filename":"src/main/java/com/alibaba/fastjson/PropertyNamingStrategy.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/PropertyNamingStrategy.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/PropertyNamingStrategy.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/PropertyNamingStrategy.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,74 @@\n+package com.alibaba.fastjson;\n+\n+/**\n+ * @since 1.2.15\n+ */\n+public enum PropertyNamingStrategy {\n+                                    CamelCase, // camelCase\n+                                    PascalCase, // PascalCase\n+                                    SnakeCase, // snake_case\n+                                    KebabCase, // kebab-case\n+                                    NoChange,  //\n+                                    NeverUseThisValueExceptDefaultValue;\n+\n+    public String translate(String propertyName) {\n+        switch (this) {\n+            case SnakeCase: {\n+                StringBuilder buf = new StringBuilder();\n+                for (int i = 0; i < propertyName.length(); ++i) {\n+                    char ch = propertyName.charAt(i);\n+                    if (ch >= 'A' && ch <= 'Z') {\n+                        char ch_ucase = (char) (ch + 32);\n+                        if (i > 0) {\n+                            buf.append('_');\n+                        }\n+                        buf.append(ch_ucase);\n+                    } else {\n+                        buf.append(ch);\n+                    }\n+                }\n+                return buf.toString();\n+            }\n+            case KebabCase: {\n+                StringBuilder buf = new StringBuilder();\n+                for (int i = 0; i < propertyName.length(); ++i) {\n+                    char ch = propertyName.charAt(i);\n+                    if (ch >= 'A' && ch <= 'Z') {\n+                        char ch_ucase = (char) (ch + 32);\n+                        if (i > 0) {\n+                            buf.append('-');\n+                        }\n+                        buf.append(ch_ucase);\n+                    } else {\n+                        buf.append(ch);\n+                    }\n+                }\n+                return buf.toString();\n+            }\n+            case PascalCase: {\n+                char ch = propertyName.charAt(0);\n+                if (ch >= 'a' && ch <= 'z') {\n+                    char[] chars = propertyName.toCharArray();\n+                    chars[0] -= 32;\n+                    return new String(chars);\n+                }\n+\n+                return propertyName;\n+            }\n+            case CamelCase: {\n+                char ch = propertyName.charAt(0);\n+                if (ch >= 'A' && ch <= 'Z') {\n+                    char[] chars = propertyName.toCharArray();\n+                    chars[0] += 32;\n+                    return new String(chars);\n+                }\n+\n+                return propertyName;\n+            }\n+            case NoChange:\n+            case NeverUseThisValueExceptDefaultValue:\n+            default:\n+                return propertyName;\n+        }\n+    }\n+}"},{"sha":"bf21cb5d75ba0a6bbc820cc6ba41c6ddfadb7c3c","filename":"src/main/java/com/alibaba/fastjson/TypeReference.java","status":"added","additions":141,"deletions":0,"changes":141,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/TypeReference.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/TypeReference.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/TypeReference.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,141 @@\n+package com.alibaba.fastjson;\n+\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import com.alibaba.fastjson.util.ParameterizedTypeImpl;\n+import com.alibaba.fastjson.util.TypeUtils;\n+\n+/** \n+ * Represents a generic type {@code T}. Java doesn't yet provide a way to\n+ * represent generic types, so this class does. Forces clients to create a\n+ * subclass of this class which enables retrieval the type information even at\n+ * runtime.\n+ *\n+ * <p>For example, to create a type literal for {@code List<String>}, you can\n+ * create an empty anonymous inner class:\n+ *\n+ * <pre>\n+ * TypeReference&lt;List&lt;String&gt;&gt; list = new TypeReference&lt;List&lt;String&gt;&gt;() {};\n+ * </pre>\n+ * This syntax cannot be used to create type literals that have wildcard\n+ * parameters, such as {@code Class<?>} or {@code List<? extends CharSequence>}.\n+ */\n+public class TypeReference<T> {\n+    static ConcurrentMap<Type, Type> classTypeCache\n+            = new ConcurrentHashMap<Type, Type>(16, 0.75f, 1);\n+\n+    protected final Type type;\n+\n+    /**\n+     * Constructs a new type literal. Derives represented class from type\n+     * parameter.\n+     *\n+     * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n+     * parameter in the anonymous class's type hierarchy so we can reconstitute it\n+     * at runtime despite erasure.\n+     */\n+    protected TypeReference(){\n+        Type superClass = getClass().getGenericSuperclass();\n+\n+        Type type = ((ParameterizedType) superClass).getActualTypeArguments()[0];\n+\n+        Type cachedType = classTypeCache.get(type);\n+        if (cachedType == null) {\n+            classTypeCache.putIfAbsent(type, type);\n+            cachedType = classTypeCache.get(type);\n+        }\n+\n+        this.type = cachedType;\n+    }\n+\n+    /**\n+     * @since 1.2.9\n+     * @param actualTypeArguments\n+     */\n+    protected TypeReference(Type... actualTypeArguments){\n+        Class<?> thisClass = this.getClass();\n+        Type superClass = thisClass.getGenericSuperclass();\n+\n+        ParameterizedType argType = (ParameterizedType) ((ParameterizedType) superClass).getActualTypeArguments()[0];\n+        Type rawType = argType.getRawType();\n+        Type[] argTypes = argType.getActualTypeArguments();\n+\n+        int actualIndex = 0;\n+        for (int i = 0; i < argTypes.length; ++i) {\n+            if (argTypes[i] instanceof TypeVariable &&\n+                    actualIndex < actualTypeArguments.length) {\n+                argTypes[i] = actualTypeArguments[actualIndex++];\n+            }\n+            // fix for openjdk and android env\n+            if (argTypes[i] instanceof GenericArrayType) {\n+                argTypes[i] = TypeUtils.checkPrimitiveArray(\n+                        (GenericArrayType) argTypes[i]);\n+            }\n+\n+            // \n+            if(argTypes[i] instanceof ParameterizedType) {\n+                argTypes[i] = handlerParameterizedType((ParameterizedType) argTypes[i], actualTypeArguments, actualIndex);\n+            }\n+        }\n+\n+        Type key = new ParameterizedTypeImpl(argTypes, thisClass, rawType);\n+        Type cachedType = classTypeCache.get(key);\n+        if (cachedType == null) {\n+            classTypeCache.putIfAbsent(key, key);\n+            cachedType = classTypeCache.get(key);\n+        }\n+\n+        type = cachedType;\n+    }\n+\n+    public static Type intern(ParameterizedTypeImpl type) {\n+        Type cachedType = classTypeCache.get(type);\n+        if (cachedType == null) {\n+            classTypeCache.putIfAbsent(type, type);\n+            cachedType = classTypeCache.get(type);\n+        }\n+\n+        return cachedType;\n+    }\n+\n+    private Type handlerParameterizedType(ParameterizedType type, Type[] actualTypeArguments, int actualIndex) {\n+        Class<?> thisClass = this.getClass();\n+        Type rawType = type.getRawType();\n+        Type[] argTypes = type.getActualTypeArguments();\n+\n+        for(int i = 0; i < argTypes.length; ++i) {\n+            if (argTypes[i] instanceof TypeVariable && actualIndex < actualTypeArguments.length) {\n+                argTypes[i] = actualTypeArguments[actualIndex++];\n+            }\n+\n+            // fix for openjdk and android env\n+            if (argTypes[i] instanceof GenericArrayType) {\n+                argTypes[i] = TypeUtils.checkPrimitiveArray(\n+                        (GenericArrayType) argTypes[i]);\n+            }\n+\n+            // \n+            if(argTypes[i] instanceof ParameterizedType) {\n+                argTypes[i] = handlerParameterizedType((ParameterizedType) argTypes[i], actualTypeArguments, actualIndex);\n+            }\n+        }\n+\n+        Type key = new ParameterizedTypeImpl(argTypes, thisClass, rawType);\n+        return key;\n+    }\n+    \n+    /**\n+     * Gets underlying {@code Type} instance.\n+     */\n+    public Type getType() {\n+        return type;\n+    }\n+\n+    public final static Type LIST_STRING = new TypeReference<List<String>>() {}.getType();\n+}"},{"sha":"10224689d0890e9978253c66d8cfff4c98e32a8b","filename":"src/main/java/com/alibaba/fastjson/annotation/JSONCreator.java","status":"added","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/annotation/JSONCreator.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/annotation/JSONCreator.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/annotation/JSONCreator.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,12 @@\n+package com.alibaba.fastjson.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ ElementType.CONSTRUCTOR, ElementType.METHOD })\n+public @interface JSONCreator {\n+\n+}"},{"sha":"e859d76924185d3dd5ac6d6ea763dad39ef73cbf","filename":"src/main/java/com/alibaba/fastjson/annotation/JSONField.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/annotation/JSONField.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/annotation/JSONField.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/annotation/JSONField.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,89 @@\n+/*\r\n+ * Copyright 1999-2017 Alibaba Group.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *      http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package com.alibaba.fastjson.annotation;\r\n+\r\n+import java.lang.annotation.ElementType;\r\n+import java.lang.annotation.Retention;\r\n+import java.lang.annotation.RetentionPolicy;\r\n+import java.lang.annotation.Target;\r\n+\r\n+import com.alibaba.fastjson.parser.Feature;\r\n+import com.alibaba.fastjson.serializer.SerializerFeature;\r\n+\r\n+/**\r\n+ * @author wenshao[szujobs@hotmail.com]\r\n+ */\r\n+@Retention(RetentionPolicy.RUNTIME)\r\n+@Target({ ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER })\r\n+public @interface JSONField {\r\n+    /**\r\n+     * config encode/decode ordinal\r\n+     * @since 1.1.42\r\n+     * @return\r\n+     */\r\n+    int ordinal() default 0;\r\n+\r\n+    String name() default \"\";\r\n+\r\n+    String format() default \"\";\r\n+\r\n+    boolean serialize() default true;\r\n+\r\n+    boolean deserialize() default true;\r\n+\r\n+    SerializerFeature[] serialzeFeatures() default {};\r\n+\r\n+    Feature[] parseFeatures() default {};\r\n+    \r\n+    String label() default \"\";\r\n+    \r\n+    /**\r\n+     * @since 1.2.12\r\n+     */\r\n+    boolean jsonDirect() default false;\r\n+    \r\n+    /**\r\n+     * Serializer class to use for serializing associated value.\r\n+     * \r\n+     * @since 1.2.16\r\n+     */\r\n+    Class<?> serializeUsing() default Void.class;\r\n+    \r\n+    /**\r\n+     * Deserializer class to use for deserializing associated value. \r\n+     * \r\n+     * @since 1.2.16 \r\n+     */\r\n+    Class<?> deserializeUsing() default Void.class;\r\n+\r\n+    /**\r\n+     * @since 1.2.21\r\n+     * @return the alternative names of the field when it is deserialized\r\n+     */\r\n+    String[] alternateNames() default {};\r\n+\r\n+    /**\r\n+     * @since 1.2.31\r\n+     */\r\n+    boolean unwrapped() default false;\r\n+    \r\n+\t/**\r\n+\t * Only support Object\r\n+\t * \r\n+\t * @since 1.2.61\r\n+\t */\r\n+\tString defaultValue() default \"\";\r\n+}\r"},{"sha":"7e708294dd68c05523c58fa3ffa894860fc5892d","filename":"src/main/java/com/alibaba/fastjson/annotation/JSONPOJOBuilder.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/annotation/JSONPOJOBuilder.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/annotation/JSONPOJOBuilder.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/annotation/JSONPOJOBuilder.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,42 @@\n+package com.alibaba.fastjson.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * \n+ * @since 1.2.8\n+ *\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ ElementType.TYPE })\n+public @interface JSONPOJOBuilder {\n+    /**\n+     * Property to use for re-defining which zero-argument method\n+     * is considered the actual \"build-method\": method called after\n+     * all data has been bound, and the actual instance needs to\n+     * be instantiated.\n+     *<p>\n+     * Default value is \"build\".\n+     */\n+    String buildMethod() default \"build\";\n+\n+    /**\n+     * Property used for (re)defining name prefix to use for\n+     * auto-detecting \"with-methods\": methods that are similar to\n+     * \"set-methods\" (in that they take an argument), but that\n+     * may also return the new builder instance to use\n+     * (which may be 'this', or a new modified builder instance).\n+     * Note that in addition to this prefix, it is also possible\n+     * to use {@link com.alibaba.fastjson.annotation.JSONField}\n+     * annotation to indicate \"with-methods\".\n+     *<p>\n+     * Default value is \"with\", so that method named \"withValue()\"\n+     * would be used for binding JSON property \"value\" (using type\n+     * indicated by the argument; or one defined with annotations.\n+     */\n+    String withPrefix() default \"with\";\n+\n+}"},{"sha":"39f1fe6e043c5a301686f952744f8781a7f1bebd","filename":"src/main/java/com/alibaba/fastjson/annotation/JSONType.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/annotation/JSONType.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/annotation/JSONType.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/annotation/JSONType.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,80 @@\n+package com.alibaba.fastjson.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.alibaba.fastjson.PropertyNamingStrategy;\n+import com.alibaba.fastjson.parser.Feature;\n+import com.alibaba.fastjson.parser.ParserConfig;\n+import com.alibaba.fastjson.serializer.SerializeFilter;\n+import com.alibaba.fastjson.serializer.SerializerFeature;\n+\n+/**\n+ * @author wenshao[szujobs@hotmail.com]\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ ElementType.TYPE })\n+public @interface JSONType {\n+\n+    boolean asm() default true;\n+\n+    String[] orders() default {};\n+\n+    /**\n+     * @since 1.2.6\n+     */\n+    String[] includes() default {};\n+\n+    String[] ignores() default {};\n+\n+    SerializerFeature[] serialzeFeatures() default {};\n+    Feature[] parseFeatures() default {};\n+    \n+    boolean alphabetic() default true;\n+    \n+    Class<?> mappingTo() default Void.class;\n+    \n+    Class<?> builder() default Void.class;\n+    \n+    /**\n+     * @since 1.2.11\n+     */\n+    String typeName() default \"\";\n+\n+    /**\n+     * @since 1.2.32\n+     */\n+    String typeKey() default \"\";\n+    \n+    /**\n+     * @since 1.2.11\n+     */\n+    Class<?>[] seeAlso() default{};\n+    \n+    /**\n+     * @since 1.2.14\n+     */\n+    Class<?> serializer() default Void.class;\n+    \n+    /**\n+     * @since 1.2.14\n+     */\n+    Class<?> deserializer() default Void.class;\n+\n+    boolean serializeEnumAsJavaBean() default false;\n+\n+    PropertyNamingStrategy naming() default PropertyNamingStrategy.NeverUseThisValueExceptDefaultValue;\n+\n+    /**\n+     * @since 1.2.49\n+     */\n+    Class<? extends SerializeFilter>[] serialzeFilters() default {};\n+\n+    /**\n+     * @since 1.2.71\n+     * @return\n+     */\n+    Class<? extends ParserConfig.AutoTypeCheckHandler> autoTypeCheckHandler() default ParserConfig.AutoTypeCheckHandler.class;\n+}"},{"sha":"2d437ea92b4ebc27c7cf8b274a322ee6d54f04eb","filename":"src/main/java/com/alibaba/fastjson/asm/ByteVector.java","status":"added","additions":232,"deletions":0,"changes":232,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/ByteVector.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/ByteVector.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/asm/ByteVector.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,232 @@\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.alibaba.fastjson.asm;\n+\n+/**\n+ * A dynamically extensible vector of bytes. This class is roughly equivalent to\n+ * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.\n+ *\n+ * @author Eric Bruneton\n+ */\n+public class ByteVector {\n+\n+\t/**\n+\t * The content of this vector.\n+\t */\n+\tpublic byte[] data;\n+\n+\t/**\n+\t * Actual number of bytes in this vector.\n+\t */\n+\tpublic int length;\n+\n+\t/**\n+\t * Constructs a new {@link ByteVector ByteVector} with a default initial size.\n+\t */\n+\tpublic ByteVector() {\n+\t\tdata = new byte[64];\n+\t}\n+\n+\t/**\n+\t * Constructs a new {@link ByteVector ByteVector} with the given initial size.\n+\t *\n+\t * @param initialSize the initial size of the byte vector to be constructed.\n+\t */\n+\tpublic ByteVector(final int initialSize) {\n+\t\tdata = new byte[initialSize];\n+\t}\n+\n+\t/**\n+\t * Puts a byte into this byte vector. The byte vector is automatically enlarged\n+\t * if necessary.\n+\t *\n+\t * @param b a byte.\n+\t * @return this byte vector.\n+\t */\n+\tpublic ByteVector putByte(final int b) {\n+\t\tint length = this.length;\n+\t\tif (length + 1 > data.length) {\n+\t\t\tenlarge(1);\n+\t\t}\n+\t\tdata[length++] = (byte) b;\n+\t\tthis.length = length;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Puts two bytes into this byte vector. The byte vector is automatically\n+\t * enlarged if necessary.\n+\t *\n+\t * @param b1 a byte.\n+\t * @param b2 another byte.\n+\t * @return this byte vector.\n+\t */\n+\tByteVector put11(final int b1, final int b2) {\n+\t\tint length = this.length;\n+\t\tif (length + 2 > data.length) {\n+\t\t\tenlarge(2);\n+\t\t}\n+\t\tfinal byte[] data = this.data;\n+\t\tdata[length++] = (byte) b1;\n+\t\tdata[length++] = (byte) b2;\n+\t\tthis.length = length;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Puts a short into this byte vector. The byte vector is automatically enlarged\n+\t * if necessary.\n+\t *\n+\t * @param s a short.\n+\t * @return this byte vector.\n+\t */\n+\tpublic ByteVector putShort(final int s) {\n+\t\tint length = this.length;\n+\t\tif (length + 2 > data.length) {\n+\t\t\tenlarge(2);\n+\t\t}\n+\t\tfinal byte[] data = this.data;\n+\t\tdata[length++] = (byte) (s >>> 8);\n+\t\tdata[length++] = (byte) s;\n+\t\tthis.length = length;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Puts a byte and a short into this byte vector. The byte vector is\n+\t * automatically enlarged if necessary.\n+\t *\n+\t * @param b a byte.\n+\t * @param s a short.\n+\t * @return this byte vector.\n+\t */\n+\tpublic ByteVector put12(final int b, final int s) {\n+\t\tint length = this.length;\n+\t\tif (length + 3 > data.length) {\n+\t\t\tenlarge(3);\n+\t\t}\n+\t\tfinal byte[] data = this.data;\n+\t\tdata[length++] = (byte) b;\n+\t\tdata[length++] = (byte) (s >>> 8);\n+\t\tdata[length++] = (byte) s;\n+\t\tthis.length = length;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Puts an int into this byte vector. The byte vector is automatically enlarged\n+\t * if necessary.\n+\t *\n+\t * @param i an int.\n+\t * @return this byte vector.\n+\t */\n+\tpublic ByteVector putInt(final int i) {\n+\t\tint length = this.length;\n+\t\tif (length + 4 > data.length) {\n+\t\t\tenlarge(4);\n+\t\t}\n+\t\tfinal byte[] data = this.data;\n+\t\tdata[length++] = (byte) (i >>> 24);\n+\t\tdata[length++] = (byte) (i >>> 16);\n+\t\tdata[length++] = (byte) (i >>> 8);\n+\t\tdata[length++] = (byte) i;\n+\t\tthis.length = length;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Puts an UTF8 string into this byte vector. The byte vector is automatically\n+\t * enlarged if necessary.\n+\t *\n+\t * @param s a String.\n+\t * @return this byte vector.\n+\t */\n+\tpublic ByteVector putUTF8(final String s) {\n+\t\tfinal int charLength = s.length();\n+\t\tint len = length;\n+\t\tif (len + 2 + charLength > data.length) {\n+\t\t\tenlarge(2 + charLength);\n+\t\t}\n+\t\tfinal byte[] data = this.data;\n+\t\t// optimistic algorithm: instead of computing the byte length and then\n+\t\t// serializing the string (which requires two loops), we assume the byte\n+\t\t// length is equal to char length (which is the most frequent case), and\n+\t\t// we start serializing the string right away. During the serialization,\n+\t\t// if we find that this assumption is wrong, we continue with the\n+\t\t// general method.\n+\t\tdata[len++] = (byte) (charLength >>> 8);\n+\t\tdata[len++] = (byte) charLength;\n+\t\tfor (int i = 0; i < charLength; ++i) {\n+\t\t\tfinal char c = s.charAt(i);\n+\t\t\tif ((c >= '\\001' && c <= '\\177') || (c >= '\\u4E00' && c <= '\\u9FFF')) {\n+\t\t\t\tdata[len++] = (byte) c;\n+\t\t\t} else {\n+\t\t\t\tthrow new UnsupportedOperationException();\n+\t\t\t}\n+\t\t}\n+\t\tlength = len;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Puts an array of bytes into this byte vector. The byte vector is\n+\t * automatically enlarged if necessary.\n+\t *\n+\t * @param b   an array of bytes. May be <tt>null</tt> to put <tt>len</tt> null\n+\t *            bytes into this byte vector.\n+\t * @param off index of the fist byte of b that must be copied.\n+\t * @param len number of bytes of b that must be copied.\n+\t * @return this byte vector.\n+\t */\n+\tpublic ByteVector putByteArray(final byte[] b, final int off, final int len) {\n+\t\tif (length + len > data.length) {\n+\t\t\tenlarge(len);\n+\t\t}\n+\t\tif (b != null) {\n+\t\t\tSystem.arraycopy(b, off, data, length, len);\n+\t\t}\n+\t\tlength += len;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Enlarge this byte vector so that it can receive n more bytes.\n+\t *\n+\t * @param size number of additional bytes that this byte vector should be able\n+\t *             to receive.\n+\t */\n+\tprivate void enlarge(final int size) {\n+\t\tfinal int length1 = 2 * data.length;\n+\t\tfinal int length2 = length + size;\n+\t\tfinal byte[] newData = new byte[length1 > length2 ? length1 : length2];\n+\t\tSystem.arraycopy(data, 0, newData, 0, length);\n+\t\tdata = newData;\n+\t}\n+}"},{"sha":"11cb6f3706dcd3056e31750d0cee80b0128d7bc0","filename":"src/main/java/com/alibaba/fastjson/asm/ClassReader.java","status":"added","additions":334,"deletions":0,"changes":334,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/ClassReader.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/ClassReader.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/asm/ClassReader.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,334 @@\n+package com.alibaba.fastjson.asm;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * Created by wenshao on 05/08/2017.\n+ */\n+public class ClassReader {\n+    public  final byte[] b;\n+    private final int[] items;\n+    private final String[] strings;\n+    private final int maxStringLength;\n+    public  final int header;\n+    private boolean readAnnotations;\n+\n+    public ClassReader(InputStream is, boolean readAnnotations) throws IOException {\n+        this.readAnnotations = readAnnotations;\n+\n+        {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            byte[] buf = new byte[1024];\n+            for (; ; ) {\n+                int len = is.read(buf);\n+                if (len == -1) {\n+                    break;\n+                }\n+\n+                if (len > 0) {\n+                    out.write(buf, 0, len);\n+                }\n+            }\n+            is.close();\n+            this.b = out.toByteArray();\n+        }\n+\n+        // parses the constant pool\n+        items = new int[readUnsignedShort(8)];\n+        int n = items.length;\n+        strings = new String[n];\n+        int max = 0;\n+        int index = 10;\n+        for (int i = 1; i < n; ++i) {\n+            items[i] = index + 1;\n+            int size;\n+            switch (b[index]) {\n+                case 9: // FIELD:\n+                case 10: // METH:\n+                case 11: //IMETH:\n+                case 3: //INT:\n+                case 4: //FLOAT:\n+                case 18: //INVOKEDYN:\n+                case 12: //NAME_TYPE:\n+                    size = 5;\n+                    break;\n+                case 5: //LONG:\n+                case 6: //DOUBLE:\n+                    size = 9;\n+                    ++i;\n+                    break;\n+                case 15: //MHANDLE:\n+                    size = 4;\n+                    break;\n+                case 1: //UTF8:\n+                    size = 3 + readUnsignedShort(index + 1);\n+                    if (size > max) {\n+                        max = size;\n+                    }\n+                    break;\n+                // case HamConstants.CLASS:\n+                // case HamConstants.STR:\n+                default:\n+                    size = 3;\n+                    break;\n+            }\n+            index += size;\n+        }\n+        maxStringLength = max;\n+        // the class header information starts just after the constant pool\n+        header = index;\n+    }\n+\n+    public void accept(final TypeCollector classVisitor) {\n+        char[] c = new char[maxStringLength]; // buffer used to read strings\n+        int i, j; // loop variables\n+        int u, v; // indexes in b\n+        int anns = 0;\n+\n+        //read annotations\n+        if (readAnnotations) {\n+            u = getAttributes();\n+            for (i = readUnsignedShort(u); i > 0; --i) {\n+                String attrName = readUTF8(u + 2, c);\n+                if (\"RuntimeVisibleAnnotations\".equals(attrName)) {\n+                    anns = u + 8;\n+                    break;\n+                }\n+                u += 6 + readInt(u + 4);\n+            }\n+        }\n+\n+        // visits the header\n+        u = header;\n+        int len = readUnsignedShort(u + 6);\n+        u += 8;\n+        for (i = 0; i < len; ++i) {\n+            u += 2;\n+        }\n+        v = u;\n+        i = readUnsignedShort(v);\n+        v += 2;\n+        for (; i > 0; --i) {\n+            j = readUnsignedShort(v + 6);\n+            v += 8;\n+            for (; j > 0; --j) {\n+                v += 6 + readInt(v + 2);\n+            }\n+        }\n+        i = readUnsignedShort(v);\n+        v += 2;\n+        for (; i > 0; --i) {\n+            j = readUnsignedShort(v + 6);\n+            v += 8;\n+            for (; j > 0; --j) {\n+                v += 6 + readInt(v + 2);\n+            }\n+        }\n+\n+        i = readUnsignedShort(v);\n+        v += 2;\n+        for (; i > 0; --i) {\n+            v += 6 + readInt(v + 2);\n+        }\n+\n+        if (anns != 0) {\n+            for (i = readUnsignedShort(anns), v = anns + 2; i > 0; --i) {\n+                String name = readUTF8(v, c);\n+                classVisitor.visitAnnotation(name);\n+            }\n+        }\n+\n+        // visits the fields\n+        i = readUnsignedShort(u);\n+        u += 2;\n+        for (; i > 0; --i) {\n+            j = readUnsignedShort(u + 6);\n+            u += 8;\n+            for (; j > 0; --j) {\n+                u += 6 + readInt(u + 2);\n+            }\n+        }\n+\n+        // visits the methods\n+        i = readUnsignedShort(u);\n+        u += 2;\n+        for (; i > 0; --i) {\n+            // inlined in original ASM source, now a method call\n+            u = readMethod(classVisitor, c, u);\n+        }\n+    }\n+\n+    private int getAttributes() {\n+        // skips the header\n+        int u = header + 8 + readUnsignedShort(header + 6) * 2;\n+        // skips fields and methods\n+        for (int i = readUnsignedShort(u); i > 0; --i) {\n+            for (int j = readUnsignedShort(u + 8); j > 0; --j) {\n+                u += 6 + readInt(u + 12);\n+            }\n+            u += 8;\n+        }\n+        u += 2;\n+        for (int i = readUnsignedShort(u); i > 0; --i) {\n+            for (int j = readUnsignedShort(u + 8); j > 0; --j) {\n+                u += 6 + readInt(u + 12);\n+            }\n+            u += 8;\n+        }\n+        // the attribute_info structure starts just after the methods\n+        return u + 2;\n+    }\n+\n+    private int readMethod(TypeCollector classVisitor, char[] c, int u) {\n+        int v;\n+        int w;\n+        int j;\n+        String attrName;\n+        int k;\n+        int access = readUnsignedShort(u);\n+        String name = readUTF8(u + 2, c);\n+        String desc = readUTF8(u + 4, c);\n+        v = 0;\n+        w = 0;\n+\n+        // looks for Code and Exceptions attributes\n+        j = readUnsignedShort(u + 6);\n+        u += 8;\n+        for (; j > 0; --j) {\n+            attrName = readUTF8(u, c);\n+            int attrSize = readInt(u + 2);\n+            u += 6;\n+            // tests are sorted in decreasing frequency order\n+            // (based on frequencies observed on typical classes)\n+            if (attrName.equals(\"Code\")) {\n+                v = u;\n+            }\n+            u += attrSize;\n+        }\n+        // reads declared exceptions\n+        if (w == 0) {\n+        } else {\n+            w += 2;\n+            for (j = 0; j < readUnsignedShort(w); ++j) {\n+                w += 2;\n+            }\n+        }\n+\n+        // visits the method's code, if any\n+        MethodCollector mv = classVisitor.visitMethod(access, name, desc);\n+\n+        if (mv != null && v != 0) {\n+            int codeLength = readInt(v + 4);\n+            v += 8;\n+\n+            int codeStart = v;\n+            int codeEnd = v + codeLength;\n+            v = codeEnd;\n+\n+            j = readUnsignedShort(v);\n+            v += 2;\n+            for (; j > 0; --j) {\n+                v += 8;\n+            }\n+            // parses the local variable, line number tables, and code\n+            // attributes\n+            int varTable = 0;\n+            int varTypeTable = 0;\n+            j = readUnsignedShort(v);\n+            v += 2;\n+            for (; j > 0; --j) {\n+                attrName = readUTF8(v, c);\n+                if (attrName.equals(\"LocalVariableTable\")) {\n+                    varTable = v + 6;\n+                } else if (attrName.equals(\"LocalVariableTypeTable\")) {\n+                    varTypeTable = v + 6;\n+                }\n+                v += 6 + readInt(v + 2);\n+            }\n+\n+            v = codeStart;\n+            // visits the local variable tables\n+            if (varTable != 0) {\n+                if (varTypeTable != 0) {\n+                    k = readUnsignedShort(varTypeTable) * 3;\n+                    w = varTypeTable + 2;\n+                    int[] typeTable = new int[k];\n+                    while (k > 0) {\n+                        typeTable[--k] = w + 6; // signature\n+                        typeTable[--k] = readUnsignedShort(w + 8); // index\n+                        typeTable[--k] = readUnsignedShort(w); // start\n+                        w += 10;\n+                    }\n+                }\n+                k = readUnsignedShort(varTable);\n+                w = varTable + 2;\n+                for (; k > 0; --k) {\n+                    int index = readUnsignedShort(w + 8);\n+                    mv.visitLocalVariable(readUTF8(w + 4, c), index);\n+                    w += 10;\n+                }\n+            }\n+        }\n+        return u;\n+    }\n+\n+    private int readUnsignedShort(final int index) {\n+        byte[] b = this.b;\n+        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n+    }\n+\n+    private int readInt(final int index) {\n+        byte[] b = this.b;\n+        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16)\n+                | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n+    }\n+\n+    private String readUTF8(int index, final char[] buf) {\n+        int item = readUnsignedShort(index);\n+        String s = strings[item];\n+        if (s != null) {\n+            return s;\n+        }\n+        index = items[item];\n+        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);\n+    }\n+\n+    private String readUTF(int index, final int utfLen, final char[] buf) {\n+        int endIndex = index + utfLen;\n+        byte[] b = this.b;\n+        int strLen = 0;\n+        int c;\n+        int st = 0;\n+        char cc = 0;\n+        while (index < endIndex) {\n+            c = b[index++];\n+            switch (st) {\n+                case 0:\n+                    c = c & 0xFF;\n+                    if (c < 0x80) {  // 0xxxxxxx\n+                        buf[strLen++] = (char) c;\n+                    } else if (c < 0xE0 && c > 0xBF) {  // 110x xxxx 10xx xxxx\n+                        cc = (char) (c & 0x1F);\n+                        st = 1;\n+                    } else {  // 1110 xxxx 10xx xxxx 10xx xxxx\n+                        cc = (char) (c & 0x0F);\n+                        st = 2;\n+                    }\n+                    break;\n+\n+                case 1:  // byte 2 of 2-byte char or byte 3 of 3-byte char\n+                    buf[strLen++] = (char) ((cc << 6) | (c & 0x3F));\n+                    st = 0;\n+                    break;\n+\n+                case 2:  // byte 2 of 3-byte char\n+                    cc = (char) ((cc << 6) | (c & 0x3F));\n+                    st = 1;\n+                    break;\n+            }\n+        }\n+        return new String(buf, 0, strLen);\n+    }\n+}"},{"sha":"7bcf97bd56b0587657fc7ad4cbd8e5ad1af59e3e","filename":"src/main/java/com/alibaba/fastjson/asm/ClassWriter.java","status":"added","additions":391,"deletions":0,"changes":391,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/ClassWriter.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/ClassWriter.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/asm/ClassWriter.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,391 @@\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.alibaba.fastjson.asm;\n+\n+/**\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class ClassWriter {\n+    /**\n+     * Minor and major version numbers of the class to be generated.\n+     */\n+    int                     version;\n+\n+    /**\n+     * Index of the next item to be added in the constant pool.\n+     */\n+    int                     index;\n+\n+    /**\n+     * The constant pool of this class.\n+     */\n+    final ByteVector        pool;\n+\n+    /**\n+     * The constant pool's hash table data.\n+     */\n+    Item[]                  items;\n+\n+    /**\n+     * The threshold of the constant pool's hash table.\n+     */\n+    int                     threshold;\n+\n+    /**\n+     * A reusable key used to look for items in the {@link #items} hash table.\n+     */\n+    final Item              key;\n+\n+    /**\n+     * A reusable key used to look for items in the {@link #items} hash table.\n+     */\n+    final Item              key2;\n+\n+    /**\n+     * A reusable key used to look for items in the {@link #items} hash table.\n+     */\n+    final Item              key3;\n+\n+    /**\n+     * A type table used to temporarily store internal names that will not necessarily be stored in the constant pool.\n+     * This type table is used by the control flow and data flow analysis algorithm used to compute stack map frames\n+     * from scratch. This array associates to each index <tt>i</tt> the Item whose index is <tt>i</tt>. All Item objects\n+     * stored in this array are also stored in the {@link #items} hash table. These two arrays allow to retrieve an Item\n+     * from its index or, conversely, to get the index of an Item from its value. Each Item stores an internal name in\n+     * its {@link Item#strVal1} field.\n+     */\n+    Item[]                  typeTable;\n+\n+    /**\n+     * The access flags of this class.\n+     */\n+    private int             access;\n+\n+    /**\n+     * The constant pool item that contains the internal name of this class.\n+     */\n+    private int             name;\n+\n+    /**\n+     * The internal name of this class.\n+     */\n+    String                  thisName;\n+\n+    /**\n+     * The constant pool item that contains the internal name of the super class of this class.\n+     */\n+    private int             superName;\n+\n+    /**\n+     * Number of interfaces implemented or extended by this class or interface.\n+     */\n+    private int             interfaceCount;\n+\n+    /**\n+     * The interfaces implemented or extended by this class or interface. More precisely, this array contains the\n+     * indexes of the constant pool items that contain the internal names of these interfaces.\n+     */\n+    private int[]           interfaces;\n+\n+    /**\n+     * The fields of this class. These fields are stored in a linked list of {@link FieldWriter} objects, linked to each\n+     * other by their {@link FieldWriter#next} field. This field stores the first element of this list.\n+     */\n+    FieldWriter             firstField;\n+\n+    /**\n+     * The fields of this class. These fields are stored in a linked list of {@link FieldWriter} objects, linked to each\n+     * other by their {@link FieldWriter#next} field. This field stores the last element of this list.\n+     */\n+    FieldWriter             lastField;\n+\n+    /**\n+     * The methods of this class. These methods are stored in a linked list of {@link MethodWriter} objects, linked to\n+     * each other by their {@link MethodWriter#next} field. This field stores the first element of this list.\n+     */\n+    MethodWriter            firstMethod;\n+\n+    /**\n+     * The methods of this class. These methods are stored in a linked list of {@link MethodWriter} objects, linked to\n+     * each other by their {@link MethodWriter#next} field. This field stores the last element of this list.\n+     */\n+    MethodWriter            lastMethod;\n+\n+    // ------------------------------------------------------------------------\n+    // Constructor\n+    // ------------------------------------------------------------------------\n+\n+    public ClassWriter(){\n+        this(0);\n+    }\n+\n+    private ClassWriter(final int flags){\n+        index = 1;\n+        pool = new ByteVector();\n+        items = new Item[256];\n+        threshold = (int) (0.75d * items.length);\n+        key = new Item();\n+        key2 = new Item();\n+        key3 = new Item();\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the ClassVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visit(final int version, final int access, final String name, final String superName, final String[] interfaces) {\n+        this.version = version;\n+        this.access = access;\n+        this.name = newClassItem(name).index;\n+        thisName = name;\n+        this.superName = superName == null ? 0 : newClassItem(superName).index;\n+        if (interfaces != null && interfaces.length > 0) {\n+            interfaceCount = interfaces.length;\n+            this.interfaces = new int[interfaceCount];\n+            for (int i = 0; i < interfaceCount; ++i) {\n+                this.interfaces[i] = newClassItem(interfaces[i]).index;\n+            }\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Other public methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the bytecode of the class that was build with this class writer.\n+     * \n+     * @return the bytecode of the class that was build with this class writer.\n+     */\n+    public byte[] toByteArray() {\n+        // computes the real size of the bytecode of this class\n+        int size = 24 + 2 * interfaceCount;\n+        int nbFields = 0;\n+        FieldWriter fb = firstField;\n+        while (fb != null) {\n+            ++nbFields;\n+            size += fb.getSize();\n+            fb = fb.next;\n+        }\n+        int nbMethods = 0;\n+        MethodWriter mb = firstMethod;\n+        while (mb != null) {\n+            ++nbMethods;\n+            size += mb.getSize();\n+            mb = mb.next;\n+        }\n+        int attributeCount = 0;\n+        size += pool.length;\n+        // allocates a byte vector of this size, in order to avoid unnecessary\n+        // arraycopy operations in the ByteVector.enlarge() method\n+        ByteVector out = new ByteVector(size);\n+        out.putInt(0xCAFEBABE).putInt(version);\n+        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n+        int mask = 393216; // Opcodes.ACC_DEPRECATED | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE | ((access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / (ClassWriter.ACC_SYNTHETIC_ATTRIBUTE / Opcodes.ACC_SYNTHETIC));\n+        out.putShort(access & ~mask).putShort(name).putShort(superName);\n+        out.putShort(interfaceCount);\n+        for (int i = 0; i < interfaceCount; ++i) {\n+            out.putShort(interfaces[i]);\n+        }\n+        out.putShort(nbFields);\n+        fb = firstField;\n+        while (fb != null) {\n+            fb.put(out);\n+            fb = fb.next;\n+        }\n+        out.putShort(nbMethods);\n+        mb = firstMethod;\n+        while (mb != null) {\n+            mb.put(out);\n+            mb = mb.next;\n+        }\n+        out.putShort(attributeCount);\n+        return out.data;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods: constant pool management\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Adds a number or string constant to the constant pool of the class being build. Does nothing if the constant pool\n+     * already contains a similar item.\n+     * \n+     * @param cst the value of the constant to be added to the constant pool. This parameter must be an {@link Integer},\n+     * a {@link Float}, a {@link Long}, a {@link Double}, a {@link String} or a {@link Type}.\n+     * @return a new or already existing constant item with the given value.\n+     */\n+    Item newConstItem(final Object cst) {\n+        if (cst instanceof Integer) {\n+            int val = ((Integer) cst).intValue();\n+            // return newInteger(val);\n+            key.set(val);\n+            Item result = get(key);\n+            if (result == null) {\n+                pool.putByte(3 /* INT */ ).putInt(val);\n+                result = new Item(index++, key);\n+                put(result);\n+            }\n+            return result;\n+        } else if (cst instanceof String) {\n+            return newString((String) cst);\n+        } else if (cst instanceof Type) {\n+            Type t = (Type) cst;\n+            return newClassItem(t.sort == 10 /*Type.OBJECT*/ ? t.getInternalName() : t.getDescriptor());\n+        } else {\n+            throw new IllegalArgumentException(\"value \" + cst);\n+        }\n+    }\n+\n+    public int newUTF8(final String value) {\n+        key.set(1 /* UTF8 */, value, null, null);\n+        Item result = get(key);\n+        if (result == null) {\n+            pool.putByte(1 /* UTF8 */).putUTF8(value);\n+            result = new Item(index++, key);\n+            put(result);\n+        }\n+        return result.index;\n+    }\n+\n+    public Item newClassItem(final String value) {\n+        key2.set(7 /* CLASS */, value, null, null);\n+        Item result = get(key2);\n+        if (result == null) {\n+            pool.put12(7 /* CLASS */, newUTF8(value));\n+            result = new Item(index++, key2);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Adds a field reference to the constant pool of the class being build. Does nothing if the constant pool already\n+     * contains a similar item.\n+     * \n+     * @param owner the internal name of the field's owner class.\n+     * @param name the field's name.\n+     * @param desc the field's descriptor.\n+     * @return a new or already existing field reference item.\n+     */\n+    Item newFieldItem(final String owner, final String name, final String desc) {\n+        key3.set(9 /* FIELD */, owner, name, desc);\n+        Item result = get(key3);\n+        if (result == null) {\n+            // put122(9 /* FIELD */, newClassItem(owner).index, newNameTypeItem(name, desc).index);\n+            int s1 = newClassItem(owner).index, s2 = newNameTypeItem(name, desc).index;\n+            pool.put12(9 /* FIELD */, s1).putShort(s2);\n+            result = new Item(index++, key3);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Adds a method reference to the constant pool of the class being build. Does nothing if the constant pool already\n+     * contains a similar item.\n+     * \n+     * @param owner the internal name of the method's owner class.\n+     * @param name the method's name.\n+     * @param desc the method's descriptor.\n+     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n+     * @return a new or already existing method reference item.\n+     */\n+    Item newMethodItem(final String owner, final String name, final String desc, final boolean itf) {\n+        int type = itf ? 11 /* IMETH */ : 10 /* METH */;\n+        key3.set(type, owner, name, desc);\n+        Item result = get(key3);\n+        if (result == null) {\n+            // put122(type, newClassItem(owner).index, newNameTypeItem(name, desc).index);\n+            int s1 = newClassItem(owner).index, s2 = newNameTypeItem(name, desc).index;\n+            pool.put12(type, s1).putShort(s2);\n+            result = new Item(index++, key3);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+    private Item newString(final String value) {\n+        key2.set(8 /* STR */, value, null, null);\n+        Item result = get(key2);\n+        if (result == null) {\n+            pool.put12(8 /*STR*/, newUTF8(value));\n+            result = new Item(index++, key2);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+    public Item newNameTypeItem(final String name, final String desc) {\n+        key2.set(12 /* NAME_TYPE */, name, desc, null);\n+        Item result = get(key2);\n+        if (result == null) {\n+            //put122(12 /* NAME_TYPE */, newUTF8(name), newUTF8(desc));\n+            int s1 = newUTF8(name), s2 = newUTF8(desc);\n+            pool.put12(12 /* NAME_TYPE */, s1).putShort(s2);\n+            result = new Item(index++, key2);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+\n+    private Item get(final Item key) {\n+        Item i = items[key.hashCode % items.length];\n+        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {\n+            i = i.next;\n+        }\n+        return i;\n+    }\n+\n+    private void put(final Item i) {\n+        if (index > threshold) {\n+            int ll = items.length;\n+            int nl = ll * 2 + 1;\n+            Item[] newItems = new Item[nl];\n+            for (int l = ll - 1; l >= 0; --l) {\n+                Item j = items[l];\n+                while (j != null) {\n+                    int index = j.hashCode % newItems.length;\n+                    Item k = j.next;\n+                    j.next = newItems[index];\n+                    newItems[index] = j;\n+                    j = k;\n+                }\n+            }\n+            items = newItems;\n+            threshold = (int) (nl * 0.75);\n+        }\n+        int index = i.hashCode % items.length;\n+        i.next = items[index];\n+        items[index] = i;\n+    }\n+}"},{"sha":"4a93009e4a7836d64706074ed464fb261051aca3","filename":"src/main/java/com/alibaba/fastjson/asm/FieldWriter.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/FieldWriter.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/FieldWriter.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/asm/FieldWriter.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,103 @@\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.alibaba.fastjson.asm;\n+\n+/**\n+ * An FieldWriter that generates Java fields in bytecode form.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public final class FieldWriter {\n+\n+    FieldWriter       next;\n+\n+    /**\n+     * Access flags of this field.\n+     */\n+    private final int access;\n+\n+    /**\n+     * The index of the constant pool item that contains the name of this method.\n+     */\n+    private final int name;\n+\n+    /**\n+     * The index of the constant pool item that contains the descriptor of this field.\n+     */\n+    private final int desc;\n+\n+    // ------------------------------------------------------------------------\n+    // Constructor\n+    // ------------------------------------------------------------------------\n+\n+    public FieldWriter(final ClassWriter cw, final int access, final String name, final String desc){\n+        if (cw.firstField == null) {\n+            cw.firstField = this;\n+        } else {\n+            cw.lastField.next = this;\n+        }\n+        cw.lastField = this;\n+        this.access = access;\n+        this.name = cw.newUTF8(name);\n+        this.desc = cw.newUTF8(desc);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the FieldVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visitEnd() {\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the size of this field.\n+     * \n+     * @return the size of this field.\n+     */\n+    int getSize() {\n+        return 8;\n+    }\n+\n+    /**\n+     * Puts the content of this field into the given byte vector.\n+     * \n+     * @param out where the content of this field must be put.\n+     */\n+    void put(final ByteVector out) {\n+        final int mask = 393216; // Opcodes.ACC_DEPRECATED | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE | ((access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / (ClassWriter.ACC_SYNTHETIC_ATTRIBUTE / Opcodes.ACC_SYNTHETIC));\n+        out.putShort(access & ~mask).putShort(name).putShort(desc);\n+        int attributeCount = 0;\n+        out.putShort(attributeCount);\n+    }\n+}"},{"sha":"d941c41b47a0941acc9112caf827318efd3e3221","filename":"src/main/java/com/alibaba/fastjson/asm/Item.java","status":"added","additions":177,"deletions":0,"changes":177,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/Item.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/Item.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/asm/Item.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,177 @@\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.alibaba.fastjson.asm;\n+\n+/**\n+ * A constant pool item. Constant pool items can be created with the 'newXXX' methods in the {@link ClassWriter} class.\n+ * \n+ * @author Eric Bruneton\n+ */\n+final class Item {\n+\n+    /**\n+     * Index of this item in the constant pool.\n+     */\n+    int    index;\n+\n+    int    type;\n+\n+    /**\n+     * Value of this item, for an integer item.\n+     */\n+    int    intVal;\n+\n+    /**\n+     * Value of this item, for a long item.\n+     */\n+    long   longVal;\n+\n+    /**\n+     * First part of the value of this item, for items that do not hold a primitive value.\n+     */\n+    String strVal1;\n+\n+    /**\n+     * Second part of the value of this item, for items that do not hold a primitive value.\n+     */\n+    String strVal2;\n+\n+    /**\n+     * Third part of the value of this item, for items that do not hold a primitive value.\n+     */\n+    String strVal3;\n+\n+    /**\n+     * The hash code value of this constant pool item.\n+     */\n+    int    hashCode;\n+\n+    /**\n+     * Link to another constant pool item, used for collision lists in the constant pool's hash table.\n+     */\n+    Item   next;\n+\n+    /**\n+     * Constructs an uninitialized {@link Item}.\n+     */\n+    Item(){\n+    }\n+\n+    /**\n+     * Constructs a copy of the given item.\n+     * \n+     * @param index index of the item to be constructed.\n+     * @param i the item that must be copied into the item to be constructed.\n+     */\n+    Item(final int index, final Item i){\n+        this.index = index;\n+        type = i.type;\n+        intVal = i.intVal;\n+        longVal = i.longVal;\n+        strVal1 = i.strVal1;\n+        strVal2 = i.strVal2;\n+        strVal3 = i.strVal3;\n+        hashCode = i.hashCode;\n+    }\n+\n+    /**\n+     * Sets this item to an item that do not hold a primitive value.\n+     * \n+     * @param type the type of this item.\n+     * @param strVal1 first part of the value of this item.\n+     * @param strVal2 second part of the value of this item.\n+     * @param strVal3 third part of the value of this item.\n+     */\n+    void set(final int type, final String strVal1, final String strVal2, final String strVal3) {\n+        this.type = type;\n+        this.strVal1 = strVal1;\n+        this.strVal2 = strVal2;\n+        this.strVal3 = strVal3;\n+        switch (type) {\n+            case 1 /* ClassWriter.UTF8 */:\n+            case 8 /* ClassWriter.STR */:\n+            case 7 /* ClassWriter.CLASS */:\n+            case 13 /* ClassWriter.TYPE_NORMAL */:\n+                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode());\n+                return;\n+            case 12 /* ClassWriter.NAME_TYPE */:\n+                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode() * strVal2.hashCode());\n+                return;\n+                // ClassWriter.FIELD:\n+                // ClassWriter.METH:\n+                // ClassWriter.IMETH:\n+            default:\n+                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode() * strVal2.hashCode() * strVal3.hashCode());\n+        }\n+    }\n+    \n+    /**\n+     * Sets this item to an integer item.\n+     *\n+     * @param intVal the value of this item.\n+     */\n+    void set(final int intVal) {\n+        this.type = 3 /* ClassWriter.INT */;\n+        this.intVal = intVal;\n+        this.hashCode = 0x7FFFFFFF & (type + intVal);\n+    }\n+\n+    /**\n+     * Indicates if the given item is equal to this one. <i>This method assumes that the two items have the same\n+     * {@link #type}</i>.\n+     * \n+     * @param i the item to be compared to this one. Both items must have the same {@link #type}.\n+     * @return <tt>true</tt> if the given item if equal to this one, <tt>false</tt> otherwise.\n+     */\n+    boolean isEqualTo(final Item i) {\n+        switch (type) {\n+            case 1 /* ClassWriter.UTF8 */:\n+            case 8 /* ClassWriter.STR */:\n+            case 7 /* ClassWriter.CLASS */ :\n+            case 13 /* ClassWriter.TYPE_NORMAL */ :\n+                return i.strVal1.equals(strVal1);\n+            case 15 /* ClassWriter.TYPE_MERGED */ :\n+            case 5 /* ClassWriter.LONG */ :\n+            case 6 /* ClassWriter.DOUBLE */:\n+                return i.longVal == longVal;\n+            case 3 /* ClassWriter.INT */ :\n+            case 4 /* ClassWriter.FLOAT */:\n+                return i.intVal == intVal;\n+            case 12 /* ClassWriter.NAME_TYPE */:\n+                return i.strVal1.equals(strVal1) && i.strVal2.equals(strVal2);\n+                // case ClassWriter.FIELD:\n+                // case ClassWriter.METH:\n+                // case ClassWriter.IMETH:\n+            default:\n+                return i.strVal1.equals(strVal1) && i.strVal2.equals(strVal2) && i.strVal3.equals(strVal3);\n+        }\n+    }\n+\n+}"},{"sha":"ccdf3111be7d948dfa09dd25239332a9c672fde4","filename":"src/main/java/com/alibaba/fastjson/asm/Label.java","status":"added","additions":244,"deletions":0,"changes":244,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/Label.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/Label.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/asm/Label.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,244 @@\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.alibaba.fastjson.asm;\n+\n+/**\n+ * A label represents a position in the bytecode of a method. Labels are used for jump, goto, and switch instructions,\n+ * and for try catch blocks. A label designates the <i>instruction</i> that is just after. Note however that there can\n+ * be other elements between a label and the instruction it designates (such as other labels, stack map frames, line\n+ * numbers, etc.).\n+ *\n+ * @author Eric Bruneton\n+ */\n+public class Label {\n+    int              status;\n+\n+    /**\n+     * The position of this label in the code, if known.\n+     */\n+    int              position;\n+\n+    /**\n+     * Number of forward references to this label, times two.\n+     */\n+    private int      referenceCount;\n+\n+    /**\n+     * Informations about forward references. Each forward reference is described by two consecutive integers in this\n+     * array: the first one is the position of the first byte of the bytecode instruction that contains the forward\n+     * reference, while the second is the position of the first byte of the forward reference itself. In fact the sign\n+     * of the first integer indicates if this reference uses 2 or 4 bytes, and its absolute value gives the position of\n+     * the bytecode instruction. This array is also used as a bitset to store the subroutines to which a basic block\n+     * belongs. This information is needed in MethodWriter#visitMaxs, after all forward references have been\n+     * resolved. Hence the same array can be used for both purposes without problems.\n+     */\n+    private int[]    srcAndRefPositions;\n+\n+    /**\n+     * The bit mask to extract the type of a forward reference to this label. The extracted type is\n+     * either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link #FORWARD_REFERENCE_TYPE_WIDE}.\n+     */\n+    static final int FORWARD_REFERENCE_TYPE_MASK = 0xF0000000;\n+\n+    /**\n+     * The bit mask to extract the 'handle' of a forward reference to this label. The extracted handle\n+     * is the bytecode offset where the forward reference value is stored (using either 2 or 4 bytes,\n+     * as indicated by the {@link #FORWARD_REFERENCE_TYPE_MASK}).\n+     */\n+    static final int FORWARD_REFERENCE_HANDLE_MASK = 0x0FFFFFFF;\n+\n+    /**\n+     * The type of forward references stored with two bytes in the bytecode. This is the case, for\n+     * instance, of a forward reference from an ifnull instruction.\n+     */\n+    static final int FORWARD_REFERENCE_TYPE_SHORT = 0x10000000;\n+\n+    /**\n+     * The type of forward references stored in four bytes in the bytecode. This is the case, for\n+     * instance, of a forward reference from a lookupswitch instruction.\n+     */\n+    static final int FORWARD_REFERENCE_TYPE_WIDE = 0x20000000;\n+\n+    // ------------------------------------------------------------------------\n+\n+    /*\n+     * Fields for the control flow and data flow graph analysis algorithms (used to compute the maximum stack size or\n+     * the stack map frames). A control flow graph contains one node per \"basic block\", and one edge per \"jump\" from one\n+     * basic block to another. Each node (i.e., each basic block) is represented by the Label object that corresponds to\n+     * the first instruction of this basic block. Each node also stores the list of its successors in the graph, as a\n+     * linked list of Edge objects. The control flow analysis algorithms used to compute the maximum stack size or the\n+     * stack map frames are similar and use two steps. The first step, during the visit of each instruction, builds\n+     * information about the state of the local variables and the operand stack at the end of each basic block, called\n+     * the \"output frame\", <i>relatively</i> to the frame state at the beginning of the basic block, which is called the\n+     * \"input frame\", and which is <i>unknown</i> during this step. The second step, in link MethodWriter#visitMaxs,\n+     * is a fix point algorithm that computes information about the input frame of each basic block, from the input\n+     * state of the first basic block (known from the method signature), and by the using the previously computed\n+     * relative output frames. The algorithm used to compute the maximum stack size only computes the relative output\n+     * and absolute input stack heights, while the algorithm used to compute stack map frames computes relative output\n+     * frames and absolute input frames.\n+     */\n+\n+    /**\n+     * Start of the output stack relatively to the input stack. The exact semantics of this field depends on the\n+     * algorithm that is used. When only the maximum stack size is computed, this field is the number of elements in the\n+     * input stack. When the stack map frames are completely computed, this field is the offset of the first output\n+     * stack element relatively to the top of the input stack. This offset is always negative or null. A null offset\n+     * means that the output stack must be appended to the input stack. A -n offset means that the first n output stack\n+     * elements must replace the top n input stack elements, and that the other elements must be appended to the input\n+     * stack.\n+     */\n+    int              inputStackTop;\n+\n+    /**\n+     * Maximum height reached by the output stack, relatively to the top of the input stack. This maximum is always\n+     * positive or null.\n+     */\n+    int              outputStackMax;\n+\n+    /**\n+     * The successor of this label, in the order they are visited. This linked list does not include labels used for\n+     * debug info only. If ClassWriter#COMPUTE_FRAMES option is used then, in addition, it does not contain\n+     * successive labels that denote the same bytecode position (in this case only the first label appears in this\n+     * list).\n+     */\n+    Label            successor;\n+\n+    /**\n+     * The next basic block in the basic block stack. This stack is used in the main loop of the fix point algorithm\n+     * used in the second step of the control flow analysis algorithms. It is also used in {@link #visitSubroutine} to\n+     * avoid using a recursive method.\n+     *\n+     * @see MethodWriter#visitMaxs\n+     */\n+    Label            next;\n+\n+    // ------------------------------------------------------------------------\n+    // Constructor\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Constructs a new label.\n+     */\n+    public Label(){\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Methods to compute offsets and to manage forward references\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Puts a reference to this label in the bytecode of a method. If the position of the label is known, the offset is\n+     * computed and written directly. Otherwise, a null offset is written and a new forward reference is declared for\n+     * this label.\n+     *\n+     * @param owner the code writer that calls this method.\n+     * @param out the bytecode of the method.\n+     * @param source the position of first byte of the bytecode instruction that contains this label.\n+     * @param wideOffset <tt>true</tt> if the reference must be stored in 4 bytes, or <tt>false</tt> if it must be\n+     * stored with 2 bytes.\n+     * @throws IllegalArgumentException if this label has not been created by the given code writer.\n+     */\n+    void put(final MethodWriter owner, final ByteVector out, final int source, boolean wideOffset) {\n+        if ((status & 2 /* RESOLVED */) == 0) {\n+            if (wideOffset) {\n+                addReference(source, out.length, FORWARD_REFERENCE_TYPE_WIDE);\n+                out.putInt(-1);\n+            } else {\n+                addReference(source, out.length, FORWARD_REFERENCE_TYPE_SHORT);\n+                out.putShort(-1);\n+            }\n+        } else {\n+            if (wideOffset) {\n+                out.putInt(position - source);\n+            } else {\n+                out.putShort(position - source);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds a forward reference to this label. This method must be called only for a true forward reference, i.e. only\n+     * if this label is not resolved yet. For backward references, the offset of the reference can be, and must be,\n+     * computed and stored directly.\n+     *\n+     * @param sourcePosition the position of the referencing instruction. This position will be used to compute the\n+     * offset of this forward reference.\n+     * @param referencePosition the position where the offset for this forward reference must be stored.\n+     */\n+    private void addReference(final int sourcePosition, final int referencePosition, final int referenceType) {\n+        if (srcAndRefPositions == null) {\n+            srcAndRefPositions = new int[6];\n+        }\n+        if (referenceCount >= srcAndRefPositions.length) {\n+            int[] a = new int[srcAndRefPositions.length + 6];\n+            System.arraycopy(srcAndRefPositions, 0, a, 0, srcAndRefPositions.length);\n+            srcAndRefPositions = a;\n+        }\n+        srcAndRefPositions[referenceCount++] = sourcePosition;\n+        srcAndRefPositions[referenceCount++] = referencePosition | referenceType;\n+    }\n+\n+    /**\n+     * Resolves all forward references to this label. This method must be called when this label is added to the\n+     * bytecode of the method, i.e. when its position becomes known. This method fills in the blanks that where left in\n+     * the bytecode by each forward reference previously added to this label.\n+     *\n+     * @param owner the code writer that calls this method.\n+     * @param position the position of this label in the bytecode.\n+     * @param data the bytecode of the method.\n+     * @return <tt>true</tt> if a blank that was left for this label was to small to store the offset. In such a case\n+     * the corresponding jump instruction is replaced with a pseudo instruction (using unused opcodes) using an unsigned\n+     * two bytes offset. These pseudo instructions will need to be replaced with true instructions with wider offsets (4\n+     * bytes instead of 2). This is done in {@link MethodWriter#resizeInstructions}.\n+     * @throws IllegalArgumentException if this label has already been resolved, or if it has not been created by the\n+     * given code writer.\n+     */\n+    void resolve(final MethodWriter owner, final int position, final byte[] data) {\n+        this.status |= 2 /* RESOLVED */ ;\n+        this.position = position;\n+        int i = 0;\n+        while (i < referenceCount) {\n+            int source = srcAndRefPositions[i++];\n+            int reference = srcAndRefPositions[i++];\n+            int handle = reference & FORWARD_REFERENCE_HANDLE_MASK;\n+            int offset = position - source;\n+            if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {\n+                data[handle++] = (byte) (offset >>> 8);\n+                data[handle] = (byte) offset;\n+            } else {\n+                data[handle++] = (byte) (offset >>> 24);\n+                data[handle++] = (byte) (offset >>> 16);\n+                data[handle++] = (byte) (offset >>> 8);\n+                data[handle] = (byte) offset;\n+            }\n+        }\n+    }\n+\n+}"},{"sha":"9f04b8f46be9d55b92788a83075dafe9e80e3b5f","filename":"src/main/java/com/alibaba/fastjson/asm/MethodCollector.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/MethodCollector.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/MethodCollector.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/asm/MethodCollector.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,41 @@\n+package com.alibaba.fastjson.asm;\n+\n+/**\n+ * Created by wenshao on 05/08/2017.\n+ */\n+public class MethodCollector {\n+\n+    private final int paramCount;\n+\n+    private final int ignoreCount;\n+\n+    private int currentParameter;\n+\n+    private final StringBuilder result;\n+\n+    protected boolean debugInfoPresent;\n+\n+    protected MethodCollector(int ignoreCount, int paramCount) {\n+        this.ignoreCount = ignoreCount;\n+        this.paramCount = paramCount;\n+        this.result = new StringBuilder();\n+        this.currentParameter = 0;\n+        // if there are 0 parameters, there is no need for debug info\n+        this.debugInfoPresent = paramCount == 0;\n+    }\n+\n+    protected void visitLocalVariable(String name, int index) {\n+        if (index >= ignoreCount && index < ignoreCount + paramCount) {\n+            if (!name.equals(\"arg\" + currentParameter)) {\n+                debugInfoPresent = true;\n+            }\n+            result.append(',');\n+            result.append(name);\n+            currentParameter++;\n+        }\n+    }\n+\n+    protected String getResult() {\n+        return result.length() != 0 ? result.substring(1) : \"\";\n+    }\n+}\n\\ No newline at end of file"},{"sha":"e32a216de6c149261ff3a7b366f154ee025a1330","filename":"src/main/java/com/alibaba/fastjson/asm/MethodVisitor.java","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/MethodVisitor.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/MethodVisitor.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/asm/MethodVisitor.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,153 @@\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.alibaba.fastjson.asm;\n+\n+/**\n+ * \n+ * @author Eric Bruneton\n+ */\n+public interface MethodVisitor {\n+\n+    // -------------------------------------------------------------------------\n+    // Annotations and non standard attributes\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // Normal instructions\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * Visits a zero operand instruction.\n+     * \n+     * @param opcode the opcode of the instruction to be visited. This opcode is either NOP, ACONST_NULL, ICONST_M1,\n+     * ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2,\n+     * DCONST_0, DCONST_1, IALOAD, LALOAD, FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE,\n+     * DASTORE, AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP, IADD,\n+     * LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV, FDIV, DDIV, IREM, LREM, FREM, DREM,\n+     * INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D,\n+     * L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN,\n+     * FRETURN, DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.\n+     */\n+    void visitInsn(int opcode);\n+\n+    void visitIntInsn(int opcode, int operand);\n+\n+    /**\n+     * Visits a local variable instruction. A local variable instruction is an instruction that loads or stores the\n+     * value of a local variable.\n+     * \n+     * @param opcode the opcode of the local variable instruction to be visited. This opcode is either ILOAD, LLOAD,\n+     * FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.\n+     * @param var the operand of the instruction to be visited. This operand is the index of a local variable.\n+     */\n+    void visitVarInsn(int opcode, int var);\n+\n+    /**\n+     * Visits a type instruction. A type instruction is an instruction that takes the internal name of a class as\n+     * parameter.\n+     * \n+     * @param opcode the opcode of the type instruction to be visited. This opcode is either NEW, ANEWARRAY, CHECKCAST\n+     * or INSTANCEOF.\n+     * @param type the operand of the instruction to be visited. This operand must be the internal name of an object or\n+     * array class (see {@link Type#getInternalName() getInternalName}).\n+     */\n+    void visitTypeInsn(int opcode, String type);\n+\n+    /**\n+     * Visits a field instruction. A field instruction is an instruction that loads or stores the value of a field of an\n+     * object.\n+     * \n+     * @param opcode the opcode of the type instruction to be visited. This opcode is either GETSTATIC, PUTSTATIC,\n+     * GETFIELD or PUTFIELD.\n+     * @param owner the internal name of the field's owner class (see {@link Type#getInternalName() getInternalName}).\n+     * @param name the field's name.\n+     * @param desc the field's descriptor (see {@link Type Type}).\n+     */\n+    void visitFieldInsn(int opcode, String owner, String name, String desc);\n+\n+    void visitMethodInsn(int opcode, String owner, String name, String desc);\n+\n+    /**\n+     * Visits a jump instruction. A jump instruction is an instruction that may jump to another instruction.\n+     * \n+     * @param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ, IFNE, IFLT, IFGE,\n+     * IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR,\n+     * IFNULL or IFNONNULL.\n+     * @param label the operand of the instruction to be visited. This operand is a label that designates the\n+     * instruction to which the jump instruction may jump.\n+     */\n+    void visitJumpInsn(int opcode, Label label);\n+\n+    /**\n+     * Visits a label. A label designates the instruction that will be visited just after it.\n+     * \n+     * @param label a {@link Label Label} object.\n+     */\n+    void visitLabel(Label label);\n+\n+    // -------------------------------------------------------------------------\n+    // Special instructions\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * Visits a LDC instruction.\n+     * \n+     * @param cst the constant to be loaded on the stack. This parameter must be a non null {@link Integer}, a\n+     * {@link Float}, a {@link Long}, a {@link Double} a {@link String} (or a {@link Type} for <tt>.class</tt>\n+     * constants, for classes whose version is 49.0 or more).\n+     */\n+    void visitLdcInsn(Object cst);\n+\n+    /**\n+     * Visits an IINC instruction.\n+     * \n+     * @param var index of the local variable to be incremented.\n+     * @param increment amount to increment the local variable by.\n+     */\n+    void visitIincInsn(int var, int increment);\n+\n+    // -------------------------------------------------------------------------\n+    // Exceptions table entries, debug information, max stack and max locals\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * Visits the maximum stack size and the maximum number of local variables of the method.\n+     * \n+     * @param maxStack maximum stack size of the method.\n+     * @param maxLocals maximum number of local variables for the method.\n+     */\n+    void visitMaxs(int maxStack, int maxLocals);\n+\n+    /**\n+     * Visits the end of the method. This method, which is the last one to be called, is used to inform the visitor that\n+     * all the annotations and attributes of the method have been visited.\n+     */\n+    void visitEnd();\n+}"},{"sha":"743f63479eb082356689466c239665e6f6cae53d","filename":"src/main/java/com/alibaba/fastjson/asm/MethodWriter.java","status":"added","additions":314,"deletions":0,"changes":314,"blob_url":"https://github.com/EricLee543/Testbench/blob/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/MethodWriter.java","raw_url":"https://github.com/EricLee543/Testbench/raw/994bc215b0c03e72fdbd8b7e2204b42eeb35b08d/src/main/java/com/alibaba/fastjson/asm/MethodWriter.java","contents_url":"https://api.github.com/repos/EricLee543/Testbench/contents/src/main/java/com/alibaba/fastjson/asm/MethodWriter.java?ref=994bc215b0c03e72fdbd8b7e2204b42eeb35b08d","patch":"@@ -0,0 +1,314 @@\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.alibaba.fastjson.asm;\n+\n+/**\n+ * @author Eric Bruneton\n+ * @author Eugene Kuleshov\n+ */\n+public class MethodWriter implements MethodVisitor {\n+\n+    /**\n+     * Next method writer (see {@link ClassWriter#firstMethod firstMethod}).\n+     */\n+    MethodWriter       next;\n+\n+    /**\n+     * The class writer to which this method must be added.\n+     */\n+    final ClassWriter  cw;\n+\n+    /**\n+     * Access flags of this method.\n+     */\n+    private int        access;\n+\n+    /**\n+     * The index of the constant pool item that contains the name of this method.\n+     */\n+    private final int  name;\n+\n+    /**\n+     * The index of the constant pool item that contains the descriptor of this method.\n+     */\n+    private final int  desc;\n+\n+    /**\n+     * Number of exceptions that can be thrown by this method.\n+     */\n+    int                exceptionCount;\n+\n+    /**\n+     * The exceptions that can be thrown by this method. More precisely, this array contains the indexes of the constant\n+     * pool items that contain the internal names of these exception classes.\n+     */\n+    int[]              exceptions;\n+\n+    /**\n+     * The bytecode of this method.\n+     */\n+    private ByteVector code                                    = new ByteVector();\n+\n+    /**\n+     * Maximum stack size of this method.\n+     */\n+    private int        maxStack;\n+\n+    /**\n+     * Maximum number of local variables for this method.\n+     */\n+    private int        maxLocals;\n+\n+    // ------------------------------------------------------------------------\n+\n+    /*\n+     * Fields for the control flow graph analysis algorithm (used to compute the maximum stack size). A control flow\n+     * graph contains one node per \"basic block\", and one edge per \"jump\" from one basic block to another. Each node\n+     * (i.e., each basic block) is represented by the Label object that corresponds to the first instruction of this\n+     * basic block. Each node also stores the list of its successors in the graph, as a linked list of Edge objects.\n+     */\n+\n+    // ------------------------------------------------------------------------\n+    // Constructor\n+    // ------------------------------------------------------------------------\n+\n+    public MethodWriter(final ClassWriter cw, final int access, final String name, final String desc, final String signature, final String[] exceptions){\n+        if (cw.firstMethod == null) {\n+            cw.firstMethod = this;\n+        } else {\n+            cw.lastMethod.next = this;\n+        }\n+        cw.lastMethod = this;\n+        this.cw = cw;\n+        this.access = access;\n+        this.name = cw.newUTF8(name);\n+        this.desc = cw.newUTF8(desc);\n+\n+        if (exceptions != null && exceptions.length > 0) {\n+            exceptionCount = exceptions.length;\n+            this.exceptions = new int[exceptionCount];\n+            for (int i = 0; i < exceptionCount; ++i) {\n+                this.exceptions[i] = cw.newClassItem(exceptions[i]).index;\n+            }\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the MethodVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visitInsn(final int opcode) {\n+        // adds the instruction to the bytecode of the method\n+        code.putByte(opcode);\n+        // update currentBlock\n+        // Label currentBlock = this.currentBlock;\n+    }\n+\n+    public void visitIntInsn(final int opcode, final int operand) {\n+        // Label currentBlock = this.currentBlock;\n+        // adds the instruction to the bytecode of the method\n+        // if (opcode == Opcodes.SIPUSH) {\n+        // code.put12(opcode, operand);\n+        // } else { // BIPUSH or NEWARRAY\n+        code.put11(opcode, operand);\n+        // }\n+    }\n+\n+    public void visitVarInsn(final int opcode, final int var) {\n+        // Label currentBlock = this.currentBlock;\n+        // adds the instruction to the bytecode of the method\n+        if (var < 4 && opcode != Opcodes.RET) {\n+            int opt;\n+            if (opcode < Opcodes.ISTORE) {\n+                /* ILOAD_0 */\n+                opt = 26 + ((opcode - Opcodes.ILOAD) << 2) + var;\n+            } else {\n+                /* ISTORE_0 */\n+                opt = 59 + ((opcode - Opcodes.ISTORE) << 2) + var;\n+            }\n+            code.putByte(opt);\n+        } else if (var >= 256) {\n+            code.putByte(196 /* WIDE */).put12(opcode, var);\n+        } else {\n+            code.put11(opcode, var);\n+        }\n+    }\n+\n+    public void visitTypeInsn(final int opcode, final String type) {\n+        Item i = cw.newClassItem(type);\n+        // Label currentBlock = this.currentBlock;\n+        // adds the instruction to the bytecode of the method\n+        code.put12(opcode, i.index);\n+    }\n+\n+    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc) {\n+        Item i = cw.newFieldItem(owner, name, desc);\n+        // Label currentBlock = this.currentBlock;\n+        // adds the instruction to the bytecode of the method\n+        code.put12(opcode, i.index);\n+    }\n+\n+    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) {\n+        boolean itf = opcode == Opcodes.INVOKEINTERFACE;\n+        Item i = cw.newMethodItem(owner, name, desc, itf);\n+        int argSize = i.intVal;\n+        // Label currentBlock = this.currentBlock;\n+        // adds the instruction to the bytecode of the method\n+        if (itf) {\n+            if (argSize == 0) {\n+                argSize = Type.getArgumentsAndReturnSizes(desc);\n+                i.intVal = argSize;\n+            }\n+            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);\n+        } else {\n+            code.put12(opcode, i.index);\n+        }\n+    }\n+\n+    public void visitJumpInsn(final int opcode, final Label label) {\n+        // Label currentBlock = this.currentBlock;\n+        // adds the instruction to the bytecode of the method\n+        if ((label.status & 2 /* Label.RESOLVED */ ) != 0 && label.position - code.length < Short.MIN_VALUE) {\n+            throw new UnsupportedOperationException();\n+        } else {\n+            /*\n+             * case of a backward jump with an offset >= -32768, or of a forward jump with, of course, an unknown\n+             * offset. In these cases we store the offset in 2 bytes (which will be increased in resizeInstructions, if\n+             * needed).\n+             */\n+            code.putByte(opcode);\n+            // Currently, GOTO_W is the only supported wide reference\n+            label.put(this, code, code.length - 1, opcode == Opcodes.GOTO_W);\n+        }\n+    }\n+\n+    public void visitLabel(final Label label) {\n+        // resolves previous forward references to label, if any\n+        label.resolve(this, code.length, code.data);\n+    }\n+\n+    public void visitLdcInsn(final Object cst) {\n+        Item i = cw.newConstItem(cst);\n+        // Label currentBlock = this.currentBlock;\n+        // adds the instruction to the bytecode of the method\n+        int index = i.index;\n+        if (i.type == 5 /* ClassWriter.LONG */ || i.type == 6 /* ClassWriter.DOUBLE */) {\n+            code.put12(20 /* LDC2_W */, index);\n+        } else if (index >= 256) {\n+            code.put12(19 /* LDC_W */, index);\n+        } else {\n+            code.put11(18 /*Opcodes.LDC*/, index);\n+        }\n+    }\n+\n+    public void visitIincInsn(final int var, final int increment) {\n+        // adds the instruction to the bytecode of the method\n+//        if ((var > 255) || (increment > 127) || (increment < -128)) {\n+//            code.putByte(196 /* WIDE */).put12(Opcodes.IINC, var).putShort(increment);\n+//        } else {\n+            code.putByte(132 /* Opcodes.IINC*/ ).put11(var, increment);\n+//        }\n+    }\n+\n+    public void visitMaxs(final int maxStack, final int maxLocals) {\n+        this.maxStack = maxStack;\n+        this.maxLocals = maxLocals;\n+    }\n+\n+    public void visitEnd() {\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods: control flow analysis algorithm\n+    // ------------------------------------------------------------------------\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods: stack map frames\n+    // ------------------------------------------------------------------------\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods: dump bytecode array\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the size of the bytecode of this method.\n+     * \n+     * @return the size of the bytecode of this method.\n+     */\n+    final int getSize() {\n+        int size = 8;\n+        if (code.length > 0) {\n+            cw.newUTF8(\"Code\");\n+            size += 18 + code.length + 8 * 0;\n+        }\n+        if (exceptionCount > 0) {\n+            cw.newUTF8(\"Exceptions\");\n+            size += 8 + 2 * exceptionCount;\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Puts the bytecode of this method in the given byte vector.\n+     * \n+     * @param out the byte vector into which the bytecode of this method must be copied.\n+     */\n+    final void put(final ByteVector out) {\n+        final int mask = 393216; //Opcodes.ACC_DEPRECATED | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE | ((access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / (ClassWriter.ACC_SYNTHETIC_ATTRIBUTE / Opcodes.ACC_SYNTHETIC));\n+        out.putShort(access & ~mask).putShort(name).putShort(desc);\n+        int attributeCount = 0;\n+        if (code.length > 0) {\n+            ++attributeCount;\n+        }\n+        if (exceptionCount > 0) {\n+            ++attributeCount;\n+        }\n+\n+        out.putShort(attributeCount);\n+        if (code.length > 0) {\n+            int size = 12 + code.length + 8 * 0; // handlerCount\n+            out.putShort(cw.newUTF8(\"Code\")).putInt(size);\n+            out.putShort(maxStack).putShort(maxLocals);\n+            out.putInt(code.length).putByteArray(code.data, 0, code.length);\n+            out.putShort(0); // handlerCount\n+            attributeCount = 0;\n+            out.putShort(attributeCount);\n+        }\n+        if (exceptionCount > 0) {\n+            out.putShort(cw.newUTF8(\"Exceptions\")).putInt(2 * exceptionCount + 2);\n+            out.putShort(exceptionCount);\n+            for (int i = 0; i < exceptionCount; ++i) {\n+                out.putShort(exceptions[i]);\n+            }\n+        }\n+\n+    }\n+\n+}"}]